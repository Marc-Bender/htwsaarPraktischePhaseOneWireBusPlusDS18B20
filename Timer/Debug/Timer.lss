
Timer.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000b8  00800100  00001762  000017f6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001762  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000478  008001b8  008001b8  000018ae  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000018ae  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000190c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003f8  00000000  00000000  0000194c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000342b  00000000  00000000  00001d44  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000012cb  00000000  00000000  0000516f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001713  00000000  00000000  0000643a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000994  00000000  00000000  00007b50  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001b04  00000000  00000000  000084e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001a44  00000000  00000000  00009fe8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000348  00000000  00000000  0000ba2c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	bf c0       	rjmp	.+382    	; 0x180 <__dtors_end>
       2:	00 00       	nop
       4:	b7 c2       	rjmp	.+1390   	; 0x574 <__vector_1>
       6:	00 00       	nop
       8:	e1 c0       	rjmp	.+450    	; 0x1cc <__bad_interrupt>
       a:	00 00       	nop
       c:	df c0       	rjmp	.+446    	; 0x1cc <__bad_interrupt>
       e:	00 00       	nop
      10:	dd c0       	rjmp	.+442    	; 0x1cc <__bad_interrupt>
      12:	00 00       	nop
      14:	db c0       	rjmp	.+438    	; 0x1cc <__bad_interrupt>
      16:	00 00       	nop
      18:	d9 c0       	rjmp	.+434    	; 0x1cc <__bad_interrupt>
      1a:	00 00       	nop
      1c:	87 c6       	rjmp	.+3342   	; 0xd2c <__vector_7>
      1e:	00 00       	nop
      20:	d5 c0       	rjmp	.+426    	; 0x1cc <__bad_interrupt>
      22:	00 00       	nop
      24:	5c c6       	rjmp	.+3256   	; 0xcde <__vector_9>
      26:	00 00       	nop
      28:	d1 c0       	rjmp	.+418    	; 0x1cc <__bad_interrupt>
      2a:	00 00       	nop
      2c:	cf c0       	rjmp	.+414    	; 0x1cc <__bad_interrupt>
      2e:	00 00       	nop
      30:	cd c0       	rjmp	.+410    	; 0x1cc <__bad_interrupt>
      32:	00 00       	nop
      34:	cb c0       	rjmp	.+406    	; 0x1cc <__bad_interrupt>
      36:	00 00       	nop
      38:	03 c6       	rjmp	.+3078   	; 0xc40 <__vector_14>
      3a:	00 00       	nop
      3c:	c7 c0       	rjmp	.+398    	; 0x1cc <__bad_interrupt>
      3e:	00 00       	nop
      40:	d8 c5       	rjmp	.+2992   	; 0xbf2 <__vector_16>
      42:	00 00       	nop
      44:	c3 c0       	rjmp	.+390    	; 0x1cc <__bad_interrupt>
      46:	00 00       	nop
      48:	c1 c0       	rjmp	.+386    	; 0x1cc <__bad_interrupt>
      4a:	00 00       	nop
      4c:	4c c7       	rjmp	.+3736   	; 0xee6 <__vector_19>
      4e:	00 00       	nop
      50:	bd c0       	rjmp	.+378    	; 0x1cc <__bad_interrupt>
      52:	00 00       	nop
      54:	bb c0       	rjmp	.+374    	; 0x1cc <__bad_interrupt>
      56:	00 00       	nop
      58:	b9 c0       	rjmp	.+370    	; 0x1cc <__bad_interrupt>
      5a:	00 00       	nop
      5c:	b7 c0       	rjmp	.+366    	; 0x1cc <__bad_interrupt>
      5e:	00 00       	nop
      60:	b5 c0       	rjmp	.+362    	; 0x1cc <__bad_interrupt>
      62:	00 00       	nop
      64:	b3 c0       	rjmp	.+358    	; 0x1cc <__bad_interrupt>
      66:	00 00       	nop
      68:	fc 06       	cpc	r15, r28
      6a:	02 07       	cpc	r16, r18
      6c:	08 07       	cpc	r16, r24
      6e:	0e 07       	cpc	r16, r30
      70:	14 07       	cpc	r17, r20
      72:	1a 07       	cpc	r17, r26
      74:	20 07       	cpc	r18, r16
      76:	26 07       	cpc	r18, r22
      78:	2c 07       	cpc	r18, r28
      7a:	32 07       	cpc	r19, r18

0000007c <__trampolines_end>:
      7c:	00 5e       	subi	r16, 0xE0	; 224
      7e:	bc e2       	ldi	r27, 0x2C	; 44
      80:	61 3f       	cpi	r22, 0xF1	; 241
      82:	dd 83       	std	Y+5, r29	; 0x05
      84:	c2 9c       	mul	r12, r2
      86:	7e 20       	and	r7, r14
      88:	a3 fd       	sbrc	r26, 3
      8a:	1f 41       	sbci	r17, 0x1F	; 31
      8c:	9d c3       	rjmp	.+1850   	; 0x7c8 <onReadBitEnsureLongEnoughIdleTime+0xa>
      8e:	21 7f       	andi	r18, 0xF1	; 241
      90:	fc a2       	std	Y+36, r15	; 0x24
      92:	40 1e       	adc	r4, r16
      94:	5f 01       	movw	r10, r30
      96:	e3 bd       	out	0x23, r30	; 35
      98:	3e 60       	ori	r19, 0x0E	; 14
      9a:	82 dc       	rcall	.-1788   	; 0xfffff9a0 <__eeprom_end+0xff7ef9a0>
      9c:	23 7d       	andi	r18, 0xD3	; 211
      9e:	9f c1       	rjmp	.+830    	; 0x3de <getNonIntegerPartOfSigned7Point4Fixed+0x22>
      a0:	42 1c       	adc	r4, r2
      a2:	fe a0       	ldd	r15, Y+38	; 0x26
      a4:	e1 bf       	out	0x31, r30	; 49
      a6:	5d 03       	fmul	r21, r21
      a8:	80 de       	rcall	.-768    	; 0xfffffdaa <__eeprom_end+0xff7efdaa>
      aa:	3c 62       	ori	r19, 0x2C	; 44
      ac:	be e0       	ldi	r27, 0x0E	; 14
      ae:	02 5c       	subi	r16, 0xC2	; 194
      b0:	df 81       	ldd	r29, Y+7	; 0x07
      b2:	63 3d       	cpi	r22, 0xD3	; 211
      b4:	7c 22       	and	r7, r28
      b6:	c0 9e       	mul	r12, r16
      b8:	1d 43       	sbci	r17, 0x3D	; 61
      ba:	a1 ff       	sbrs	r26, 1
      bc:	46 18       	sub	r4, r6
      be:	fa a4       	ldd	r15, Y+42	; 0x2a
      c0:	27 79       	andi	r18, 0x97	; 151
      c2:	9b c5       	rjmp	.+2870   	; 0xbfa <__vector_16+0x8>
      c4:	84 da       	rcall	.-2808   	; 0xfffff5ce <__eeprom_end+0xff7ef5ce>
      c6:	38 66       	ori	r19, 0x68	; 104
      c8:	e5 bb       	out	0x15, r30	; 21
      ca:	59 07       	cpc	r21, r25
      cc:	db 85       	ldd	r29, Y+11	; 0x0b
      ce:	67 39       	cpi	r22, 0x97	; 151
      d0:	ba e4       	ldi	r27, 0x4A	; 74
      d2:	06 58       	subi	r16, 0x86	; 134
      d4:	19 47       	sbci	r17, 0x79	; 121
      d6:	a5 fb       	bst	r26, 5
      d8:	78 26       	eor	r7, r24
      da:	c4 9a       	sbi	0x18, 4	; 24
      dc:	65 3b       	cpi	r22, 0xB5	; 181
      de:	d9 87       	std	Y+9, r29	; 0x09
      e0:	04 5a       	subi	r16, 0xA4	; 164
      e2:	b8 e6       	ldi	r27, 0x68	; 104
      e4:	a7 f9       	bld	r26, 7
      e6:	1b 45       	sbci	r17, 0x5B	; 91
      e8:	c6 98       	cbi	0x18, 6	; 24
      ea:	7a 24       	eor	r7, r10
      ec:	f8 a6       	std	Y+40, r15	; 0x28
      ee:	44 1a       	sub	r4, r20
      f0:	99 c7       	rjmp	.+3890   	; 0x1024 <malloc+0xcc>
      f2:	25 7b       	andi	r18, 0xB5	; 181
      f4:	3a 64       	ori	r19, 0x4A	; 74
      f6:	86 d8       	rcall	.-3828   	; 0xfffff204 <__eeprom_end+0xff7ef204>
      f8:	5b 05       	cpc	r21, r11
      fa:	e7 b9       	out	0x07, r30	; 7
      fc:	8c d2       	rcall	.+1304   	; 0x616 <getNonIntegerPartOfSigned11Point2Fixed+0x24>
      fe:	30 6e       	ori	r19, 0xE0	; 224
     100:	ed b3       	in	r30, 0x1d	; 29
     102:	51 0f       	add	r21, r17
     104:	4e 10       	cpse	r4, r14
     106:	f2 ac       	ldd	r15, Z+58	; 0x3a
     108:	2f 71       	andi	r18, 0x1F	; 31
     10a:	93 cd       	rjmp	.-1242   	; 0xfffffc32 <__eeprom_end+0xff7efc32>
     10c:	11 4f       	sbci	r17, 0xF1	; 241
     10e:	ad f3       	brhs	.-22     	; 0xfa <__trampolines_end+0x7e>
     110:	70 2e       	mov	r7, r16
     112:	cc 92       	st	X, r12
     114:	d3 8d       	ldd	r29, Z+27	; 0x1b
     116:	6f 31       	cpi	r22, 0x1F	; 31
     118:	b2 ec       	ldi	r27, 0xC2	; 194
     11a:	0e 50       	subi	r16, 0x0E	; 14
     11c:	af f1       	brie	.+106    	; 0x188 <__dtors_end+0x8>
     11e:	13 4d       	sbci	r17, 0xD3	; 211
     120:	ce 90       	ld	r12, -X
     122:	72 2c       	mov	r7, r2
     124:	6d 33       	cpi	r22, 0x3D	; 61
     126:	d1 8f       	std	Z+25, r29	; 0x19
     128:	0c 52       	subi	r16, 0x2C	; 44
     12a:	b0 ee       	ldi	r27, 0xE0	; 224
     12c:	32 6c       	ori	r19, 0xC2	; 194
     12e:	8e d0       	rcall	.+284    	; 0x24c <readEntireScratchpad>
     130:	53 0d       	add	r21, r3
     132:	ef b1       	in	r30, 0x0f	; 15
     134:	f0 ae       	std	Z+56, r15	; 0x38
     136:	4c 12       	cpse	r4, r28
     138:	91 cf       	rjmp	.-222    	; 0x5c <__SREG__+0x1d>
     13a:	2d 73       	andi	r18, 0x3D	; 61
     13c:	ca 94       	dec	r12
     13e:	76 28       	or	r7, r6
     140:	ab f5       	brvc	.+106    	; 0x1ac <.do_clear_bss_start>
     142:	17 49       	sbci	r17, 0x97	; 151
     144:	08 56       	subi	r16, 0x68	; 104
     146:	b4 ea       	ldi	r27, 0xA4	; 164
     148:	69 37       	cpi	r22, 0x79	; 121
     14a:	d5 8b       	std	Z+21, r29	; 0x15
     14c:	57 09       	sbc	r21, r7
     14e:	eb b5       	in	r30, 0x2b	; 43
     150:	36 68       	ori	r19, 0x86	; 134
     152:	8a d4       	rcall	.+2324   	; 0xa68 <startTemperatureConversionAndReadoutCycle>
     154:	95 cb       	rjmp	.-2262   	; 0xfffff880 <__eeprom_end+0xff7ef880>
     156:	29 77       	andi	r18, 0x79	; 121
     158:	f4 aa       	std	Z+52, r15	; 0x34
     15a:	48 16       	cp	r4, r24
     15c:	e9 b7       	in	r30, 0x39	; 57
     15e:	55 0b       	sbc	r21, r21
     160:	88 d6       	rcall	.+3344   	; 0xe72 <setBaudrate+0x8e>
     162:	34 6a       	ori	r19, 0xA4	; 164
     164:	2b 75       	andi	r18, 0x5B	; 91
     166:	97 c9       	rjmp	.-3282   	; 0xfffff496 <__eeprom_end+0xff7ef496>
     168:	4a 14       	cp	r4, r10
     16a:	f6 a8       	ldd	r15, Z+54	; 0x36
     16c:	74 2a       	or	r7, r20
     16e:	c8 96       	adiw	r24, 0x38	; 56
     170:	15 4b       	sbci	r17, 0xB5	; 181
     172:	a9 f7       	brne	.-22     	; 0x15e <__trampolines_end+0xe2>
     174:	b6 e8       	ldi	r27, 0x86	; 134
     176:	0a 54       	subi	r16, 0x4A	; 74
     178:	d7 89       	ldd	r29, Z+23	; 0x17
     17a:	6b 35       	cpi	r22, 0x5B	; 91

0000017c <__ctors_start>:
     17c:	be 05       	cpc	r27, r14

0000017e <__ctors_end>:
     17e:	e8 05       	cpc	r30, r8

00000180 <__dtors_end>:
     180:	11 24       	eor	r1, r1
     182:	1f be       	out	0x3f, r1	; 63
     184:	cf ef       	ldi	r28, 0xFF	; 255
     186:	d8 e0       	ldi	r29, 0x08	; 8
     188:	de bf       	out	0x3e, r29	; 62
     18a:	cd bf       	out	0x3d, r28	; 61

0000018c <__do_copy_data>:
     18c:	11 e0       	ldi	r17, 0x01	; 1
     18e:	a0 e0       	ldi	r26, 0x00	; 0
     190:	b1 e0       	ldi	r27, 0x01	; 1
     192:	e2 e6       	ldi	r30, 0x62	; 98
     194:	f7 e1       	ldi	r31, 0x17	; 23
     196:	02 c0       	rjmp	.+4      	; 0x19c <__do_copy_data+0x10>
     198:	05 90       	lpm	r0, Z+
     19a:	0d 92       	st	X+, r0
     19c:	a8 3b       	cpi	r26, 0xB8	; 184
     19e:	b1 07       	cpc	r27, r17
     1a0:	d9 f7       	brne	.-10     	; 0x198 <__do_copy_data+0xc>

000001a2 <__do_clear_bss>:
     1a2:	26 e0       	ldi	r18, 0x06	; 6
     1a4:	a8 eb       	ldi	r26, 0xB8	; 184
     1a6:	b1 e0       	ldi	r27, 0x01	; 1
     1a8:	01 c0       	rjmp	.+2      	; 0x1ac <.do_clear_bss_start>

000001aa <.do_clear_bss_loop>:
     1aa:	1d 92       	st	X+, r1

000001ac <.do_clear_bss_start>:
     1ac:	a0 33       	cpi	r26, 0x30	; 48
     1ae:	b2 07       	cpc	r27, r18
     1b0:	e1 f7       	brne	.-8      	; 0x1aa <.do_clear_bss_loop>

000001b2 <__do_global_ctors>:
     1b2:	10 e0       	ldi	r17, 0x00	; 0
     1b4:	cf eb       	ldi	r28, 0xBF	; 191
     1b6:	d0 e0       	ldi	r29, 0x00	; 0
     1b8:	03 c0       	rjmp	.+6      	; 0x1c0 <__do_global_ctors+0xe>
     1ba:	21 97       	sbiw	r28, 0x01	; 1
     1bc:	fe 01       	movw	r30, r28
     1be:	c6 d6       	rcall	.+3468   	; 0xf4c <__tablejump2__>
     1c0:	ce 3b       	cpi	r28, 0xBE	; 190
     1c2:	d1 07       	cpc	r29, r17
     1c4:	d1 f7       	brne	.-12     	; 0x1ba <__do_global_ctors+0x8>
     1c6:	0f d5       	rcall	.+2590   	; 0xbe6 <main>
     1c8:	0c 94 a5 0b 	jmp	0x174a	; 0x174a <__do_global_dtors>

000001cc <__bad_interrupt>:
     1cc:	19 cf       	rjmp	.-462    	; 0x0 <__vectors>

000001ce <onConvertTemperatureCommandSent>:
	internalDataReadTemperatureDS18B20.callback(); // temperature is now ready and found in the given location as 7.4 Fixed Point Signed
}

void onConvertTemperatureCommandSent(void)
{
	internalDataReadTemperatureDS18B20.callback(); // on temperatureConversionStarted
     1ce:	e0 91 f9 05 	lds	r30, 0x05F9	; 0x8005f9 <internalDataReadTemperatureDS18B20+0x2>
     1d2:	f0 91 fa 05 	lds	r31, 0x05FA	; 0x8005fa <internalDataReadTemperatureDS18B20+0x3>
     1d6:	09 95       	icall
     1d8:	08 95       	ret

000001da <onReadyToSendReadScratchpadCommand>:
	readScratchpadRegisters(true);
}

void onReadyToSendReadScratchpadCommand(void)
{
	writeByteToOneWireBus(DS18B20_ROMCommands_ReadScratchpad,true,internalDataReadSP_DS18B20.onewirepin,&onReadScratchpadCommandSent);
     1da:	40 91 01 06 	lds	r20, 0x0601	; 0x800601 <internalDataReadSP_DS18B20>
     1de:	50 91 02 06 	lds	r21, 0x0602	; 0x800602 <internalDataReadSP_DS18B20+0x1>
     1e2:	26 ec       	ldi	r18, 0xC6	; 198
     1e4:	31 e0       	ldi	r19, 0x01	; 1
     1e6:	61 e0       	ldi	r22, 0x01	; 1
     1e8:	8e eb       	ldi	r24, 0xBE	; 190
     1ea:	72 c2       	rjmp	.+1252   	; 0x6d0 <writeByteToOneWireBus>
     1ec:	08 95       	ret

000001ee <onReadyToSendConvertTemperatureCommand>:
	internalDataReadTemperatureDS18B20.callback(); // on temperatureConversionStarted
}

void onReadyToSendConvertTemperatureCommand(void)
{
	writeByteToOneWireBus(DS18B20_ROMCommands_ConvertTemperature,true,internalDataReadTemperatureDS18B20.onewirepin,&onConvertTemperatureCommandSent);
     1ee:	40 91 f7 05 	lds	r20, 0x05F7	; 0x8005f7 <internalDataReadTemperatureDS18B20>
     1f2:	50 91 f8 05 	lds	r21, 0x05F8	; 0x8005f8 <internalDataReadTemperatureDS18B20+0x1>
     1f6:	27 ee       	ldi	r18, 0xE7	; 231
     1f8:	30 e0       	ldi	r19, 0x00	; 0
     1fa:	61 e0       	ldi	r22, 0x01	; 1
     1fc:	84 e4       	ldi	r24, 0x44	; 68
     1fe:	68 c2       	rjmp	.+1232   	; 0x6d0 <writeByteToOneWireBus>
     200:	08 95       	ret

00000202 <onScratchpadReadyForTemperatureStorage>:
	internalDataReadSP_DS18B20.scratchpad=scratchpadThatContainsTheRawData;
	sendMatchRomCommand(onewirepin,deviceID,&onReadyToSendReadScratchpadCommand);
}

void onScratchpadReadyForTemperatureStorage(void)
{
     202:	0f 93       	push	r16
     204:	1f 93       	push	r17
     206:	cf 93       	push	r28
     208:	df 93       	push	r29
	*(internalDataReadTemperatureDS18B20.temperatureFixedPointFormat) = (internalDataReadSP_DS18B20.scratchpad->asStruct.temperatureMSB<<8) | internalDataReadSP_DS18B20.scratchpad->asStruct.temperatureLSB;;
     20a:	07 ef       	ldi	r16, 0xF7	; 247
     20c:	15 e0       	ldi	r17, 0x05	; 5
     20e:	f8 01       	movw	r30, r16
     210:	a4 81       	ldd	r26, Z+4	; 0x04
     212:	b5 81       	ldd	r27, Z+5	; 0x05
     214:	c1 e0       	ldi	r28, 0x01	; 1
     216:	d6 e0       	ldi	r29, 0x06	; 6
     218:	ec 81       	ldd	r30, Y+4	; 0x04
     21a:	fd 81       	ldd	r31, Y+5	; 0x05
     21c:	81 81       	ldd	r24, Z+1	; 0x01
     21e:	90 e0       	ldi	r25, 0x00	; 0
     220:	98 2f       	mov	r25, r24
     222:	88 27       	eor	r24, r24
     224:	20 81       	ld	r18, Z
     226:	82 2b       	or	r24, r18
     228:	8d 93       	st	X+, r24
     22a:	9c 93       	st	X, r25
	// no spacial post processing is necessary (not even reseting bits 14 - 11 since they have to get discarded when converted to float by a master controller anyway and reset they may interfere with the twos complement generation and would have to be masked out afterwards again) 
	free(internalDataReadSP_DS18B20.scratchpad); // free up no longer needed scratchpad
     22c:	8c 81       	ldd	r24, Y+4	; 0x04
     22e:	9d 81       	ldd	r25, Y+5	; 0x05
     230:	2b d7       	rcall	.+3670   	; 0x1088 <free>
	internalDataReadSP_DS18B20.scratchpad=NULL; // do not leave behind a pointer to invalid locations
     232:	1d 82       	std	Y+5, r1	; 0x05
     234:	1c 82       	std	Y+4, r1	; 0x04
	internalDataReadTemperatureDS18B20.callback(); // temperature is now ready and found in the given location as 7.4 Fixed Point Signed
     236:	d8 01       	movw	r26, r16
     238:	12 96       	adiw	r26, 0x02	; 2
     23a:	ed 91       	ld	r30, X+
     23c:	fc 91       	ld	r31, X
     23e:	13 97       	sbiw	r26, 0x03	; 3
     240:	09 95       	icall
}
     242:	df 91       	pop	r29
     244:	cf 91       	pop	r28
     246:	1f 91       	pop	r17
     248:	0f 91       	pop	r16
     24a:	08 95       	ret

0000024c <readEntireScratchpad>:

void readEntireScratchpad(IN_PAR const GPIOPin_t * const onewirepin, IN_PAR const uint8_t * const deviceID, OUT_PAR DS18B20_Scratchpad_t * const scratchpadThatContainsTheRawData, IN_PAR const CallbackFunctionType onEntireScratchpadRead)
{
	// do not use the normal internalData object here since subordinate state machines will use that and overwrite what ever you would write there here.
	// so use own data object for that that can also store the output parameter for this function
	internalDataReadSP_DS18B20.callback=onEntireScratchpadRead;
     24c:	e1 e0       	ldi	r30, 0x01	; 1
     24e:	f6 e0       	ldi	r31, 0x06	; 6
     250:	33 83       	std	Z+3, r19	; 0x03
     252:	22 83       	std	Z+2, r18	; 0x02
	internalDataReadSP_DS18B20.deviceId=deviceID;
     254:	77 83       	std	Z+7, r23	; 0x07
     256:	66 83       	std	Z+6, r22	; 0x06
	internalDataReadSP_DS18B20.onewirepin=onewirepin;
     258:	91 83       	std	Z+1, r25	; 0x01
     25a:	80 83       	st	Z, r24
	internalDataReadSP_DS18B20.scratchpad=scratchpadThatContainsTheRawData;
     25c:	55 83       	std	Z+5, r21	; 0x05
     25e:	44 83       	std	Z+4, r20	; 0x04
	sendMatchRomCommand(onewirepin,deviceID,&onReadyToSendReadScratchpadCommand);
     260:	4d ee       	ldi	r20, 0xED	; 237
     262:	50 e0       	ldi	r21, 0x00	; 0
     264:	dc c1       	rjmp	.+952    	; 0x61e <sendMatchRomCommand>
     266:	08 95       	ret

00000268 <issueTemperatureConversion>:
{
	writeByteToOneWireBus(DS18B20_ROMCommands_ConvertTemperature,true,internalDataReadTemperatureDS18B20.onewirepin,&onConvertTemperatureCommandSent);
}

void issueTemperatureConversion(IN_PAR const GPIOPin_t * const onewirepin, IN_PAR const bool issueCommandAtAllSensors ,IN_PAR const uint8_t * const deviceID, IN_PAR const CallbackFunctionType onTemperatureConversionStarted)
{
     268:	da 01       	movw	r26, r20
	// if issueCommandToAllSensors is true the value in deviceID is not used but must be given anyways. Its recommended to use NULL in that instance
	internalDataReadTemperatureDS18B20.callback=onTemperatureConversionStarted;
     26a:	e7 ef       	ldi	r30, 0xF7	; 247
     26c:	f5 e0       	ldi	r31, 0x05	; 5
     26e:	33 83       	std	Z+3, r19	; 0x03
     270:	22 83       	std	Z+2, r18	; 0x02
	internalDataReadTemperatureDS18B20.onewirepin = onewirepin;
     272:	91 83       	std	Z+1, r25	; 0x01
     274:	80 83       	st	Z, r24
	if(issueCommandAtAllSensors)
     276:	66 23       	and	r22, r22
     278:	21 f0       	breq	.+8      	; 0x282 <issueTemperatureConversion+0x1a>
		sendSkipRomCommand(onewirepin,&onReadyToSendConvertTemperatureCommand);
     27a:	67 ef       	ldi	r22, 0xF7	; 247
     27c:	70 e0       	ldi	r23, 0x00	; 0
     27e:	da c1       	rjmp	.+948    	; 0x634 <sendSkipRomCommand>
     280:	08 95       	ret
	else
	{
		internalDataReadTemperatureDS18B20.deviceId = deviceID;
     282:	50 93 fe 05 	sts	0x05FE, r21	; 0x8005fe <internalDataReadTemperatureDS18B20+0x7>
     286:	40 93 fd 05 	sts	0x05FD, r20	; 0x8005fd <internalDataReadTemperatureDS18B20+0x6>
		sendMatchRomCommand(onewirepin,deviceID,&onReadyToSendConvertTemperatureCommand);
     28a:	47 ef       	ldi	r20, 0xF7	; 247
     28c:	50 e0       	ldi	r21, 0x00	; 0
     28e:	bd 01       	movw	r22, r26
     290:	c6 c1       	rjmp	.+908    	; 0x61e <sendMatchRomCommand>
     292:	08 95       	ret

00000294 <readTemperature>:
	}
}

void readTemperature(IN_PAR const GPIOPin_t * const onewirepin, IN_PAR const uint8_t * const deviceID, OUT_PAR signed7Point4Fixed_t * const temperatureFixedPointFormat, OUT_PAR bool * const errorBit, IN_PAR const CallbackFunctionType onTemperatureReady)
{
     294:	ef 92       	push	r14
     296:	ff 92       	push	r15
     298:	0f 93       	push	r16
     29a:	1f 93       	push	r17
     29c:	cf 93       	push	r28
     29e:	df 93       	push	r29
     2a0:	ec 01       	movw	r28, r24
     2a2:	7b 01       	movw	r14, r22
	internalDataReadTemperatureDS18B20.callback=onTemperatureReady;
     2a4:	e7 ef       	ldi	r30, 0xF7	; 247
     2a6:	f5 e0       	ldi	r31, 0x05	; 5
     2a8:	13 83       	std	Z+3, r17	; 0x03
     2aa:	02 83       	std	Z+2, r16	; 0x02
	internalDataReadTemperatureDS18B20.temperatureFixedPointFormat=temperatureFixedPointFormat;
     2ac:	55 83       	std	Z+5, r21	; 0x05
     2ae:	44 83       	std	Z+4, r20	; 0x04
	internalDataReadTemperatureDS18B20.onewirepin=onewirepin;
     2b0:	91 83       	std	Z+1, r25	; 0x01
     2b2:	80 83       	st	Z, r24
	internalDataReadTemperatureDS18B20.deviceId=deviceID;
     2b4:	77 83       	std	Z+7, r23	; 0x07
     2b6:	66 83       	std	Z+6, r22	; 0x06
	internalDataReadTemperatureDS18B20.errorBit=errorBit;
     2b8:	31 87       	std	Z+9, r19	; 0x09
     2ba:	20 87       	std	Z+8, r18	; 0x08
	
	DS18B20_Scratchpad_t * scratchpadForReadingTemps = malloc(sizeof(DS18B20_Scratchpad_t)); // gets free-ed by the last function in the readEntireScratchpad state machine
     2bc:	89 e0       	ldi	r24, 0x09	; 9
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	4b d6       	rcall	.+3222   	; 0xf58 <malloc>
     2c2:	8c 01       	movw	r16, r24
	if(scratchpadForReadingTemps==NULL)// no space left
     2c4:	89 2b       	or	r24, r25
		deathTrap();
     2c6:	09 f4       	brne	.+2      	; 0x2ca <readTemperature+0x36>
     2c8:	7c d1       	rcall	.+760    	; 0x5c2 <deathTrap>
	readEntireScratchpad(onewirepin,deviceID,scratchpadForReadingTemps, &onScratchpadReadyForTemperatureStorage);
     2ca:	21 e0       	ldi	r18, 0x01	; 1
     2cc:	31 e0       	ldi	r19, 0x01	; 1
     2ce:	a8 01       	movw	r20, r16
     2d0:	b7 01       	movw	r22, r14
     2d2:	ce 01       	movw	r24, r28
     2d4:	bb df       	rcall	.-138    	; 0x24c <readEntireScratchpad>
}
     2d6:	df 91       	pop	r29
     2d8:	cf 91       	pop	r28
     2da:	1f 91       	pop	r17
     2dc:	0f 91       	pop	r16
     2de:	ff 90       	pop	r15
     2e0:	ef 90       	pop	r14
     2e2:	08 95       	ret

000002e4 <calculateCRC8>:

// This function comes straight from the library that i set out to replace
uint8_t calculateCRC8(IN_PAR const uint8_t * addr, IN_PAR uint8_t len)
{
	uint8_t crc = 0;
	while (len--) 
     2e4:	2f ef       	ldi	r18, 0xFF	; 255
     2e6:	26 0f       	add	r18, r22
     2e8:	66 23       	and	r22, r22
     2ea:	61 f0       	breq	.+24     	; 0x304 <calculateCRC8+0x20>
     2ec:	a8 2f       	mov	r26, r24
     2ee:	b9 2f       	mov	r27, r25
     2f0:	80 e0       	ldi	r24, 0x00	; 0
		crc = pgm_read_byte(dscrc_table + (crc ^ *addr++));
     2f2:	ed 91       	ld	r30, X+
     2f4:	e8 27       	eor	r30, r24
     2f6:	f0 e0       	ldi	r31, 0x00	; 0
     2f8:	e4 58       	subi	r30, 0x84	; 132
     2fa:	ff 4f       	sbci	r31, 0xFF	; 255
     2fc:	84 91       	lpm	r24, Z

// This function comes straight from the library that i set out to replace
uint8_t calculateCRC8(IN_PAR const uint8_t * addr, IN_PAR uint8_t len)
{
	uint8_t crc = 0;
	while (len--) 
     2fe:	21 50       	subi	r18, 0x01	; 1
     300:	c0 f7       	brcc	.-16     	; 0x2f2 <calculateCRC8+0xe>
     302:	08 95       	ret
	116,42,200,150,21,75,169,247,182,232,10,84,215,137,107,53};

// This function comes straight from the library that i set out to replace
uint8_t calculateCRC8(IN_PAR const uint8_t * addr, IN_PAR uint8_t len)
{
	uint8_t crc = 0;
     304:	80 e0       	ldi	r24, 0x00	; 0
	while (len--) 
		crc = pgm_read_byte(dscrc_table + (crc ^ *addr++));
	return crc;
}
     306:	08 95       	ret

00000308 <onScratchpadRead>:
DS18B20_ReadTemperatureInternalData_t internalDataReadTemperatureDS18B20;

uint8_t calculateCRC8(const uint8_t * const addr, const uint8_t len);

void onScratchpadRead(void)
{
     308:	cf 93       	push	r28
     30a:	df 93       	push	r29
	uint8_t calculatedCRC = calculateCRC8(internalDataReadSP_DS18B20.scratchpad->asArray, sizeof(struct scratchpadAsStruct)-1);
     30c:	c1 e0       	ldi	r28, 0x01	; 1
     30e:	d6 e0       	ldi	r29, 0x06	; 6
     310:	68 e0       	ldi	r22, 0x08	; 8
     312:	8c 81       	ldd	r24, Y+4	; 0x04
     314:	9d 81       	ldd	r25, Y+5	; 0x05
     316:	e6 df       	rcall	.-52     	; 0x2e4 <calculateCRC8>
	if(calculatedCRC!=internalDataReadSP_DS18B20.scratchpad->asStruct.CRC)
     318:	ec 81       	ldd	r30, Y+4	; 0x04
     31a:	fd 81       	ldd	r31, Y+5	; 0x05
     31c:	90 85       	ldd	r25, Z+8	; 0x08
     31e:	89 17       	cp	r24, r25
     320:	39 f0       	breq	.+14     	; 0x330 <onScratchpadRead+0x28>
		*(internalDataReadTemperatureDS18B20.errorBit) = true;	
     322:	e0 91 ff 05 	lds	r30, 0x05FF	; 0x8005ff <internalDataReadTemperatureDS18B20+0x8>
     326:	f0 91 00 06 	lds	r31, 0x0600	; 0x800600 <internalDataReadTemperatureDS18B20+0x9>
     32a:	81 e0       	ldi	r24, 0x01	; 1
     32c:	80 83       	st	Z, r24
     32e:	05 c0       	rjmp	.+10     	; 0x33a <onScratchpadRead+0x32>
	else
		*(internalDataReadTemperatureDS18B20.errorBit) = false;	
     330:	e0 91 ff 05 	lds	r30, 0x05FF	; 0x8005ff <internalDataReadTemperatureDS18B20+0x8>
     334:	f0 91 00 06 	lds	r31, 0x0600	; 0x800600 <internalDataReadTemperatureDS18B20+0x9>
     338:	10 82       	st	Z, r1
	internalDataReadSP_DS18B20.callback();
     33a:	e0 91 03 06 	lds	r30, 0x0603	; 0x800603 <internalDataReadSP_DS18B20+0x2>
     33e:	f0 91 04 06 	lds	r31, 0x0604	; 0x800604 <internalDataReadSP_DS18B20+0x3>
     342:	09 95       	icall
}
     344:	df 91       	pop	r29
     346:	cf 91       	pop	r28
     348:	08 95       	ret

0000034a <readScratchpadRegisters>:
}

void readScratchpadRegisters(IN_PAR const bool startAtZero)
{
	static uint8_t positionWithinScratchpad;
	if(startAtZero)
     34a:	81 11       	cpse	r24, r1
     34c:	05 c0       	rjmp	.+10     	; 0x358 <readScratchpadRegisters+0xe>
		positionWithinScratchpad=0;
	if(positionWithinScratchpad<sizeof(struct scratchpadAsStruct))
     34e:	90 91 b8 01 	lds	r25, 0x01B8	; 0x8001b8 <__data_end>
     352:	99 30       	cpi	r25, 0x09	; 9
     354:	b0 f4       	brcc	.+44     	; 0x382 <readScratchpadRegisters+0x38>
     356:	01 c0       	rjmp	.+2      	; 0x35a <readScratchpadRegisters+0x10>
     358:	90 e0       	ldi	r25, 0x00	; 0
		readByteFromOneWireBus(&internalDataReadSP_DS18B20.scratchpad->asArray[positionWithinScratchpad++],true,internalDataReadSP_DS18B20.onewirepin,&readNextScratchpadByte);
     35a:	e1 e0       	ldi	r30, 0x01	; 1
     35c:	f6 e0       	ldi	r31, 0x06	; 6
     35e:	40 81       	ld	r20, Z
     360:	51 81       	ldd	r21, Z+1	; 0x01
     362:	04 80       	ldd	r0, Z+4	; 0x04
     364:	f5 81       	ldd	r31, Z+5	; 0x05
     366:	e0 2d       	mov	r30, r0
     368:	81 e0       	ldi	r24, 0x01	; 1
     36a:	89 0f       	add	r24, r25
     36c:	80 93 b8 01 	sts	0x01B8, r24	; 0x8001b8 <__data_end>
     370:	23 ec       	ldi	r18, 0xC3	; 195
     372:	31 e0       	ldi	r19, 0x01	; 1
     374:	61 e0       	ldi	r22, 0x01	; 1
     376:	df 01       	movw	r26, r30
     378:	a9 0f       	add	r26, r25
     37a:	b1 1d       	adc	r27, r1
     37c:	cd 01       	movw	r24, r26
     37e:	64 c1       	rjmp	.+712    	; 0x648 <readByteFromOneWireBus>
     380:	08 95       	ret
	else
		onScratchpadRead();
     382:	c2 cf       	rjmp	.-124    	; 0x308 <onScratchpadRead>
     384:	08 95       	ret

00000386 <readNextScratchpadByte>:
     386:	80 e0       	ldi	r24, 0x00	; 0

void readScratchpadRegisters(IN_PAR const bool startAtZero);

void readNextScratchpadByte(void)
{
	readScratchpadRegisters(false);
     388:	e0 cf       	rjmp	.-64     	; 0x34a <readScratchpadRegisters>
     38a:	08 95       	ret

0000038c <onReadScratchpadCommandSent>:
		onScratchpadRead();
}

void onReadScratchpadCommandSent(void)
{
	readScratchpadRegisters(true);
     38c:	81 e0       	ldi	r24, 0x01	; 1
     38e:	dd cf       	rjmp	.-70     	; 0x34a <readScratchpadRegisters>
     390:	08 95       	ret

00000392 <getSignOfSigned7Point4Fixed>:
	return crc;
}

char getSignOfSigned7Point4Fixed(IN_PAR const signed7Point4Fixed_t num )
{
	return (num & 0xF800)?'-':'+';
     392:	88 27       	eor	r24, r24
     394:	98 7f       	andi	r25, 0xF8	; 248
     396:	89 2b       	or	r24, r25
     398:	11 f4       	brne	.+4      	; 0x39e <getSignOfSigned7Point4Fixed+0xc>
     39a:	8b e2       	ldi	r24, 0x2B	; 43
     39c:	08 95       	ret
     39e:	8d e2       	ldi	r24, 0x2D	; 45
}
     3a0:	08 95       	ret

000003a2 <getIntegerPartOfSigned7Point4Fixed>:

uint8_t getIntegerPartOfSigned7Point4Fixed(IN_PAR const signed7Point4Fixed_t num)
{
	return (uint8_t)((abs(num) & 0x07F0)>>4);
     3a2:	99 23       	and	r25, r25
     3a4:	1c f4       	brge	.+6      	; 0x3ac <getIntegerPartOfSigned7Point4Fixed+0xa>
     3a6:	91 95       	neg	r25
     3a8:	81 95       	neg	r24
     3aa:	91 09       	sbc	r25, r1
     3ac:	92 95       	swap	r25
     3ae:	82 95       	swap	r24
     3b0:	8f 70       	andi	r24, 0x0F	; 15
     3b2:	89 27       	eor	r24, r25
     3b4:	9f 70       	andi	r25, 0x0F	; 15
     3b6:	89 27       	eor	r24, r25
}
     3b8:	8f 77       	andi	r24, 0x7F	; 127
     3ba:	08 95       	ret

000003bc <getNonIntegerPartOfSigned7Point4Fixed>:

uint16_t getNonIntegerPartOfSigned7Point4Fixed(IN_PAR const signed7Point4Fixed_t num)
{
	return (((abs(num))&0x000F) * 625);
     3bc:	99 23       	and	r25, r25
     3be:	1c f4       	brge	.+6      	; 0x3c6 <getNonIntegerPartOfSigned7Point4Fixed+0xa>
     3c0:	91 95       	neg	r25
     3c2:	81 95       	neg	r24
     3c4:	91 09       	sbc	r25, r1
     3c6:	8f 70       	andi	r24, 0x0F	; 15
     3c8:	99 27       	eor	r25, r25
}
     3ca:	21 e7       	ldi	r18, 0x71	; 113
     3cc:	32 e0       	ldi	r19, 0x02	; 2
     3ce:	ac 01       	movw	r20, r24
     3d0:	42 9f       	mul	r20, r18
     3d2:	c0 01       	movw	r24, r0
     3d4:	43 9f       	mul	r20, r19
     3d6:	90 0d       	add	r25, r0
     3d8:	52 9f       	mul	r21, r18
     3da:	90 0d       	add	r25, r0
     3dc:	11 24       	eor	r1, r1
     3de:	08 95       	ret

000003e0 <writeToBuffer>:
	buf->rdIndx=0;
	buf->wrIndx=0;
}

void writeToBuffer(volatile GenericBuffers_t * const buf, const unsigned char chr)
{
     3e0:	fc 01       	movw	r30, r24
	buf->buffer[((buf->wrIndx)++)%MOD2BUFFER]=chr;
     3e2:	20 81       	ld	r18, Z
     3e4:	31 81       	ldd	r19, Z+1	; 0x01
     3e6:	c9 01       	movw	r24, r18
     3e8:	01 96       	adiw	r24, 0x01	; 1
     3ea:	91 83       	std	Z+1, r25	; 0x01
     3ec:	80 83       	st	Z, r24
     3ee:	33 70       	andi	r19, 0x03	; 3
     3f0:	e2 0f       	add	r30, r18
     3f2:	f3 1f       	adc	r31, r19
     3f4:	64 83       	std	Z+4, r22	; 0x04
     3f6:	08 95       	ret

000003f8 <readFromBuffer>:
}

unsigned char readFromBuffer(volatile GenericBuffers_t * const buf)
{
     3f8:	fc 01       	movw	r30, r24
	return buf->buffer[((buf->rdIndx)++)%MOD2BUFFER];
     3fa:	22 81       	ldd	r18, Z+2	; 0x02
     3fc:	33 81       	ldd	r19, Z+3	; 0x03
     3fe:	c9 01       	movw	r24, r18
     400:	01 96       	adiw	r24, 0x01	; 1
     402:	93 83       	std	Z+3, r25	; 0x03
     404:	82 83       	std	Z+2, r24	; 0x02
     406:	33 70       	andi	r19, 0x03	; 3
     408:	e2 0f       	add	r30, r18
     40a:	f3 1f       	adc	r31, r19
     40c:	84 81       	ldd	r24, Z+4	; 0x04
}
     40e:	08 95       	ret

00000410 <bytesAvailableInBuffer>:

__attribute__((pure)) unsigned bytesAvailableInBuffer(volatile GenericBuffers_t const * const buf)  
{
     410:	fc 01       	movw	r30, r24
  return buf->wrIndx - buf->rdIndx;
     412:	80 81       	ld	r24, Z
     414:	91 81       	ldd	r25, Z+1	; 0x01
     416:	22 81       	ldd	r18, Z+2	; 0x02
     418:	33 81       	ldd	r19, Z+3	; 0x03
}
     41a:	82 1b       	sub	r24, r18
     41c:	93 0b       	sbc	r25, r19
     41e:	08 95       	ret

00000420 <getPinState>:
	Failure to inline such a function is diagnosed as an error. Note that if such a function is called indirectly the compiler may or may not inline it depending on optimization level and a failure 
	to inline an indirect call may or may not be diagnosed.
*/

inline bool __attribute__((always_inline, optimize("O3"))) getPinState(IN_PAR const GPIOPin_t * const pin)
{
     420:	fc 01       	movw	r30, r24
	return (*(pin->PINx) & (1<<(pin->pinNumber))) > 0 ? 1 : 0;
     422:	a2 81       	ldd	r26, Z+2	; 0x02
     424:	b3 81       	ldd	r27, Z+3	; 0x03
     426:	9c 91       	ld	r25, X
     428:	21 e0       	ldi	r18, 0x01	; 1
     42a:	30 e0       	ldi	r19, 0x00	; 0
     42c:	06 80       	ldd	r0, Z+6	; 0x06
     42e:	02 c0       	rjmp	.+4      	; 0x434 <getPinState+0x14>
     430:	22 0f       	add	r18, r18
     432:	33 1f       	adc	r19, r19
     434:	0a 94       	dec	r0
     436:	e2 f7       	brpl	.-8      	; 0x430 <getPinState+0x10>
     438:	89 2f       	mov	r24, r25
     43a:	90 e0       	ldi	r25, 0x00	; 0
     43c:	28 23       	and	r18, r24
     43e:	39 23       	and	r19, r25
     440:	81 e0       	ldi	r24, 0x01	; 1
     442:	12 16       	cp	r1, r18
     444:	13 06       	cpc	r1, r19
     446:	0c f4       	brge	.+2      	; 0x44a <getPinState+0x2a>
}
     448:	08 95       	ret
	to inline an indirect call may or may not be diagnosed.
*/

inline bool __attribute__((always_inline, optimize("O3"))) getPinState(IN_PAR const GPIOPin_t * const pin)
{
	return (*(pin->PINx) & (1<<(pin->pinNumber))) > 0 ? 1 : 0;
     44a:	80 e0       	ldi	r24, 0x00	; 0
}
     44c:	08 95       	ret

0000044e <makeInput>:

inline void __attribute__((always_inline, optimize("O3"), hot)) makeInput(IN_PAR const GPIOPin_t * const pin)
{
	*(pin->DDRx) &= ~(1<<(pin->pinNumber));
     44e:	dc 01       	movw	r26, r24
     450:	ed 91       	ld	r30, X+
     452:	fc 91       	ld	r31, X
     454:	11 97       	sbiw	r26, 0x01	; 1
     456:	40 81       	ld	r20, Z
     458:	21 e0       	ldi	r18, 0x01	; 1
     45a:	30 e0       	ldi	r19, 0x00	; 0
     45c:	b9 01       	movw	r22, r18
     45e:	16 96       	adiw	r26, 0x06	; 6
     460:	0c 90       	ld	r0, X
     462:	02 c0       	rjmp	.+4      	; 0x468 <makeInput+0x1a>
     464:	66 0f       	add	r22, r22
     466:	77 1f       	adc	r23, r23
     468:	0a 94       	dec	r0
     46a:	e2 f7       	brpl	.-8      	; 0x464 <makeInput+0x16>
     46c:	cb 01       	movw	r24, r22
     46e:	80 95       	com	r24
     470:	84 23       	and	r24, r20
     472:	80 83       	st	Z, r24
     474:	08 95       	ret

00000476 <makeOutputLow>:
}

inline void __attribute__((always_inline, optimize("O3"), hot)) makeOutputLow(IN_PAR const GPIOPin_t * const pin)
{
     476:	fc 01       	movw	r30, r24
	*(pin->DDRx) |= 1<<(pin->pinNumber);
     478:	a0 81       	ld	r26, Z
     47a:	b1 81       	ldd	r27, Z+1	; 0x01
     47c:	4c 91       	ld	r20, X
     47e:	21 e0       	ldi	r18, 0x01	; 1
     480:	30 e0       	ldi	r19, 0x00	; 0
     482:	c9 01       	movw	r24, r18
     484:	06 80       	ldd	r0, Z+6	; 0x06
     486:	02 c0       	rjmp	.+4      	; 0x48c <makeOutputLow+0x16>
     488:	88 0f       	add	r24, r24
     48a:	99 1f       	adc	r25, r25
     48c:	0a 94       	dec	r0
     48e:	e2 f7       	brpl	.-8      	; 0x488 <makeOutputLow+0x12>
     490:	84 2b       	or	r24, r20
     492:	8c 93       	st	X, r24
	*(pin->PORTx) &= ~(1<<(pin->pinNumber));
     494:	a4 81       	ldd	r26, Z+4	; 0x04
     496:	b5 81       	ldd	r27, Z+5	; 0x05
     498:	8c 91       	ld	r24, X
     49a:	06 80       	ldd	r0, Z+6	; 0x06
     49c:	02 c0       	rjmp	.+4      	; 0x4a2 <makeOutputLow+0x2c>
     49e:	22 0f       	add	r18, r18
     4a0:	33 1f       	adc	r19, r19
     4a2:	0a 94       	dec	r0
     4a4:	e2 f7       	brpl	.-8      	; 0x49e <makeOutputLow+0x28>
     4a6:	20 95       	com	r18
     4a8:	28 23       	and	r18, r24
     4aa:	2c 93       	st	X, r18
     4ac:	08 95       	ret

000004ae <disablePullup>:
}

inline void disablePullup(IN_PAR const GPIOPin_t * const pin)
{
	*(pin->PORTx) &= ~(1<<(pin->pinNumber)); // only if input
     4ae:	dc 01       	movw	r26, r24
     4b0:	14 96       	adiw	r26, 0x04	; 4
     4b2:	ed 91       	ld	r30, X+
     4b4:	fc 91       	ld	r31, X
     4b6:	15 97       	sbiw	r26, 0x05	; 5
     4b8:	40 81       	ld	r20, Z
     4ba:	21 e0       	ldi	r18, 0x01	; 1
     4bc:	30 e0       	ldi	r19, 0x00	; 0
     4be:	b9 01       	movw	r22, r18
     4c0:	16 96       	adiw	r26, 0x06	; 6
     4c2:	0c 90       	ld	r0, X
     4c4:	02 c0       	rjmp	.+4      	; 0x4ca <disablePullup+0x1c>
     4c6:	66 0f       	add	r22, r22
     4c8:	77 1f       	adc	r23, r23
     4ca:	0a 94       	dec	r0
     4cc:	e2 f7       	brpl	.-8      	; 0x4c6 <disablePullup+0x18>
     4ce:	cb 01       	movw	r24, r22
     4d0:	80 95       	com	r24
     4d2:	84 23       	and	r24, r20
     4d4:	80 83       	st	Z, r24
     4d6:	08 95       	ret

000004d8 <enableExternalInterrupt>:
}

static volatile CallbackFunctionType callbacksForExternalInterrupts[NUM_OF_EXT_INTERRUPTS];

__attribute__((optimize("O3"))) void enableExternalInterrupt(IN_PAR const GPIOPin_t * const pin, IN_PAR const ExternalInteruptPolarity_t polarity, IN_PAR CallbackFunctionType onExternalInterrupt)
{
     4d8:	fc 01       	movw	r30, r24
	EICRA &= ~(0x03 << (pin->INTx * 2)); // preclear the ISCn bits
     4da:	a9 e6       	ldi	r26, 0x69	; 105
     4dc:	b0 e0       	ldi	r27, 0x00	; 0
     4de:	8c 91       	ld	r24, X
     4e0:	97 81       	ldd	r25, Z+7	; 0x07
     4e2:	99 0f       	add	r25, r25
     4e4:	23 e0       	ldi	r18, 0x03	; 3
     4e6:	30 e0       	ldi	r19, 0x00	; 0
     4e8:	01 c0       	rjmp	.+2      	; 0x4ec <enableExternalInterrupt+0x14>
     4ea:	22 0f       	add	r18, r18
     4ec:	9a 95       	dec	r25
     4ee:	ea f7       	brpl	.-6      	; 0x4ea <enableExternalInterrupt+0x12>
     4f0:	20 95       	com	r18
     4f2:	28 23       	and	r18, r24
     4f4:	2c 93       	st	X, r18
	EICRA |= polarity << (pin->INTx * 2); // set the ISCn bits
     4f6:	9c 91       	ld	r25, X
     4f8:	87 81       	ldd	r24, Z+7	; 0x07
     4fa:	88 0f       	add	r24, r24
     4fc:	01 c0       	rjmp	.+2      	; 0x500 <enableExternalInterrupt+0x28>
     4fe:	66 0f       	add	r22, r22
     500:	8a 95       	dec	r24
     502:	ea f7       	brpl	.-6      	; 0x4fe <enableExternalInterrupt+0x26>
     504:	69 2b       	or	r22, r25
     506:	6c 93       	st	X, r22
	EIMSK |= 1<<(pin->INTx);
     508:	8d b3       	in	r24, 0x1d	; 29
     50a:	21 e0       	ldi	r18, 0x01	; 1
     50c:	30 e0       	ldi	r19, 0x00	; 0
     50e:	07 80       	ldd	r0, Z+7	; 0x07
     510:	02 c0       	rjmp	.+4      	; 0x516 <enableExternalInterrupt+0x3e>
     512:	22 0f       	add	r18, r18
     514:	33 1f       	adc	r19, r19
     516:	0a 94       	dec	r0
     518:	e2 f7       	brpl	.-8      	; 0x512 <enableExternalInterrupt+0x3a>
     51a:	28 2b       	or	r18, r24
     51c:	2d bb       	out	0x1d, r18	; 29
	callbacksForExternalInterrupts[pin->INTx] = onExternalInterrupt;
     51e:	e7 81       	ldd	r30, Z+7	; 0x07
     520:	f0 e0       	ldi	r31, 0x00	; 0
     522:	ee 0f       	add	r30, r30
     524:	ff 1f       	adc	r31, r31
     526:	e7 54       	subi	r30, 0x47	; 71
     528:	fe 4f       	sbci	r31, 0xFE	; 254
     52a:	51 83       	std	Z+1, r21	; 0x01
     52c:	40 83       	st	Z, r20
     52e:	08 95       	ret

00000530 <disableExternalInterrupt>:
}

void disableExternalInterrupt(IN_PAR const GPIOPin_t * const pin)
{
     530:	fc 01       	movw	r30, r24
	EIMSK &= ~(1<<(pin->INTx)); // reset the external interrupt enable bit
     532:	9d b3       	in	r25, 0x1d	; 29
     534:	21 e0       	ldi	r18, 0x01	; 1
     536:	30 e0       	ldi	r19, 0x00	; 0
     538:	a9 01       	movw	r20, r18
     53a:	07 80       	ldd	r0, Z+7	; 0x07
     53c:	02 c0       	rjmp	.+4      	; 0x542 <disableExternalInterrupt+0x12>
     53e:	44 0f       	add	r20, r20
     540:	55 1f       	adc	r21, r21
     542:	0a 94       	dec	r0
     544:	e2 f7       	brpl	.-8      	; 0x53e <disableExternalInterrupt+0xe>
     546:	84 2f       	mov	r24, r20
     548:	80 95       	com	r24
     54a:	89 23       	and	r24, r25
     54c:	8d bb       	out	0x1d, r24	; 29
	EIFR &= ~(1<<(pin->INTx)); // reset the external interrupt status bit (makes pending interrupts non pending)
     54e:	8c b3       	in	r24, 0x1c	; 28
     550:	07 80       	ldd	r0, Z+7	; 0x07
     552:	02 c0       	rjmp	.+4      	; 0x558 <disableExternalInterrupt+0x28>
     554:	22 0f       	add	r18, r18
     556:	33 1f       	adc	r19, r19
     558:	0a 94       	dec	r0
     55a:	e2 f7       	brpl	.-8      	; 0x554 <disableExternalInterrupt+0x24>
     55c:	20 95       	com	r18
     55e:	28 23       	and	r18, r24
     560:	2c bb       	out	0x1c, r18	; 28
	callbacksForExternalInterrupts[pin->INTx] = NULL;
     562:	e7 81       	ldd	r30, Z+7	; 0x07
     564:	f0 e0       	ldi	r31, 0x00	; 0
     566:	ee 0f       	add	r30, r30
     568:	ff 1f       	adc	r31, r31
     56a:	e7 54       	subi	r30, 0x47	; 71
     56c:	fe 4f       	sbci	r31, 0xFE	; 254
     56e:	11 82       	std	Z+1, r1	; 0x01
     570:	10 82       	st	Z, r1
     572:	08 95       	ret

00000574 <__vector_1>:
}

ISR(INT0_vect)
{
     574:	1f 92       	push	r1
     576:	0f 92       	push	r0
     578:	0f b6       	in	r0, 0x3f	; 63
     57a:	0f 92       	push	r0
     57c:	11 24       	eor	r1, r1
     57e:	2f 93       	push	r18
     580:	3f 93       	push	r19
     582:	4f 93       	push	r20
     584:	5f 93       	push	r21
     586:	6f 93       	push	r22
     588:	7f 93       	push	r23
     58a:	8f 93       	push	r24
     58c:	9f 93       	push	r25
     58e:	af 93       	push	r26
     590:	bf 93       	push	r27
     592:	ef 93       	push	r30
     594:	ff 93       	push	r31
	(callbacksForExternalInterrupts[INT0])();
     596:	e0 91 b9 01 	lds	r30, 0x01B9	; 0x8001b9 <callbacksForExternalInterrupts>
     59a:	f0 91 ba 01 	lds	r31, 0x01BA	; 0x8001ba <callbacksForExternalInterrupts+0x1>
     59e:	09 95       	icall
     5a0:	ff 91       	pop	r31
     5a2:	ef 91       	pop	r30
     5a4:	bf 91       	pop	r27
     5a6:	af 91       	pop	r26
     5a8:	9f 91       	pop	r25
     5aa:	8f 91       	pop	r24
     5ac:	7f 91       	pop	r23
     5ae:	6f 91       	pop	r22
     5b0:	5f 91       	pop	r21
     5b2:	4f 91       	pop	r20
     5b4:	3f 91       	pop	r19
     5b6:	2f 91       	pop	r18
     5b8:	0f 90       	pop	r0
     5ba:	0f be       	out	0x3f, r0	; 63
     5bc:	0f 90       	pop	r0
     5be:	1f 90       	pop	r1
     5c0:	18 95       	reti

000005c2 <deathTrap>:
	#define F_CPU (16000000U)
#endif

void deathTrap(void)
{
	cli(); // Turn Off all Interrupts
     5c2:	f8 94       	cli
     5c4:	ff cf       	rjmp	.-2      	; 0x5c4 <deathTrap+0x2>

000005c6 <getSignOfSigned11Point2Fixed>:
#include "MAX31850.h"

char getSignOfSigned11Point2Fixed(IN_PAR const signed11Point2Fixed_t num )
{
	return (num & 0x8000)?'-':'+';
     5c6:	99 23       	and	r25, r25
     5c8:	14 f0       	brlt	.+4      	; 0x5ce <getSignOfSigned11Point2Fixed+0x8>
     5ca:	8b e2       	ldi	r24, 0x2B	; 43
     5cc:	08 95       	ret
     5ce:	8d e2       	ldi	r24, 0x2D	; 45
}
     5d0:	08 95       	ret

000005d2 <getIntegerPartOfSigned11Point2Fixed>:

uint16_t getIntegerPartOfSigned11Point2Fixed(IN_PAR const signed11Point2Fixed_t num)
{
	return (abs(num) & 0x7FF0)>>4;
     5d2:	99 23       	and	r25, r25
     5d4:	1c f4       	brge	.+6      	; 0x5dc <getIntegerPartOfSigned11Point2Fixed+0xa>
     5d6:	91 95       	neg	r25
     5d8:	81 95       	neg	r24
     5da:	91 09       	sbc	r25, r1
     5dc:	80 7f       	andi	r24, 0xF0	; 240
     5de:	9f 77       	andi	r25, 0x7F	; 127
}
     5e0:	95 95       	asr	r25
     5e2:	87 95       	ror	r24
     5e4:	95 95       	asr	r25
     5e6:	87 95       	ror	r24
     5e8:	95 95       	asr	r25
     5ea:	87 95       	ror	r24
     5ec:	95 95       	asr	r25
     5ee:	87 95       	ror	r24
     5f0:	08 95       	ret

000005f2 <getNonIntegerPartOfSigned11Point2Fixed>:

uint16_t getNonIntegerPartOfSigned11Point2Fixed(IN_PAR const signed11Point2Fixed_t num)
{
	return ((((abs(num)) & 0x000C)>>2) * 2500);
     5f2:	99 23       	and	r25, r25
     5f4:	1c f4       	brge	.+6      	; 0x5fc <getNonIntegerPartOfSigned11Point2Fixed+0xa>
     5f6:	91 95       	neg	r25
     5f8:	81 95       	neg	r24
     5fa:	91 09       	sbc	r25, r1
     5fc:	8c 70       	andi	r24, 0x0C	; 12
     5fe:	99 27       	eor	r25, r25
     600:	95 95       	asr	r25
     602:	87 95       	ror	r24
     604:	95 95       	asr	r25
     606:	87 95       	ror	r24
}
     608:	24 ec       	ldi	r18, 0xC4	; 196
     60a:	39 e0       	ldi	r19, 0x09	; 9
     60c:	ac 01       	movw	r20, r24
     60e:	42 9f       	mul	r20, r18
     610:	c0 01       	movw	r24, r0
     612:	43 9f       	mul	r20, r19
     614:	90 0d       	add	r25, r0
     616:	52 9f       	mul	r21, r18
     618:	90 0d       	add	r25, r0
     61a:	11 24       	eor	r1, r1
     61c:	08 95       	ret

0000061e <sendMatchRomCommand>:
	writeByteToOneWireBus(OneWireRomCommands_SkipRom,true,internalDataOneWireFrontend.onewirepin, internalDataOneWireFrontend.callback);
}

__attribute__((optimize("O3"))) void sendMatchRomCommand(IN_PAR const GPIOPin_t * const onewirepin, IN_PAR const uint8_t * const deviceID, IN_PAR const CallbackFunctionType onMatch)
{
	internalDataOneWireFrontend.onewirepin = onewirepin;
     61e:	e9 e0       	ldi	r30, 0x09	; 9
     620:	f6 e0       	ldi	r31, 0x06	; 6
     622:	93 83       	std	Z+3, r25	; 0x03
     624:	82 83       	std	Z+2, r24	; 0x02
	internalDataOneWireFrontend.callback = onMatch;
     626:	55 83       	std	Z+5, r21	; 0x05
     628:	44 83       	std	Z+4, r20	; 0x04
	internalDataOneWireFrontend.deviceId = deviceID;
     62a:	71 83       	std	Z+1, r23	; 0x01
     62c:	60 83       	st	Z, r22
	
	performFullOneWireReset(internalDataOneWireFrontend.onewirepin, &onReadyToSendMatchRomCommand);
     62e:	63 ec       	ldi	r22, 0xC3	; 195
     630:	73 e0       	ldi	r23, 0x03	; 3
     632:	91 c1       	rjmp	.+802    	; 0x956 <performFullOneWireReset>

00000634 <sendSkipRomCommand>:
}

void sendSkipRomCommand(IN_PAR const GPIOPin_t * const onewirepin, IN_PAR const CallbackFunctionType onSkip)
{
	internalDataOneWireFrontend.onewirepin = onewirepin;
     634:	e9 e0       	ldi	r30, 0x09	; 9
     636:	f6 e0       	ldi	r31, 0x06	; 6
     638:	93 83       	std	Z+3, r25	; 0x03
     63a:	82 83       	std	Z+2, r24	; 0x02
	internalDataOneWireFrontend.callback = onSkip;
     63c:	75 83       	std	Z+5, r23	; 0x05
     63e:	64 83       	std	Z+4, r22	; 0x04
	
	performFullOneWireReset(internalDataOneWireFrontend.onewirepin, &onReadyToSendSkipRomCommand);
     640:	6d ec       	ldi	r22, 0xCD	; 205
     642:	73 e0       	ldi	r23, 0x03	; 3
     644:	88 c1       	rjmp	.+784    	; 0x956 <performFullOneWireReset>
     646:	08 95       	ret

00000648 <readByteFromOneWireBus>:
	static const GPIOPin_t * lastOneWirePin;
	static bool readBit;
	
	// if run the first time with startAtZero = false then this will produce undefined behavior
	// do not use the internalData data object here since this will be used by the other functions in the subordinate state machines!!
	if(startAtZero)
     648:	66 23       	and	r22, r22
     64a:	89 f0       	breq	.+34     	; 0x66e <readByteFromOneWireBus+0x26>
	{
		posistionWithinByte = 0;
     64c:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <posistionWithinByte.2046>
		lastByte = byte;
     650:	90 93 c9 01 	sts	0x01C9, r25	; 0x8001c9 <lastByte.2045+0x1>
     654:	80 93 c8 01 	sts	0x01C8, r24	; 0x8001c8 <lastByte.2045>
		*byte=0; // ensure that the byte that holds the result is initially zero so that there are no ones in there that a simple or can not override
     658:	fc 01       	movw	r30, r24
     65a:	10 82       	st	Z, r1
		lastCallback = onByteRead;
     65c:	30 93 c7 01 	sts	0x01C7, r19	; 0x8001c7 <lastCallback.2047+0x1>
     660:	20 93 c6 01 	sts	0x01C6, r18	; 0x8001c6 <lastCallback.2047>
		lastOneWirePin = onewirepin;
     664:	50 93 c5 01 	sts	0x01C5, r21	; 0x8001c5 <lastOneWirePin.2048+0x1>
     668:	40 93 c4 01 	sts	0x01C4, r20	; 0x8001c4 <lastOneWirePin.2048>
     66c:	18 c0       	rjmp	.+48     	; 0x69e <readByteFromOneWireBus+0x56>
	}
	else
	{
		*lastByte |= ((readBit==1) ? 1 : 0 ) << posistionWithinByte;
     66e:	e0 91 c8 01 	lds	r30, 0x01C8	; 0x8001c8 <lastByte.2045>
     672:	f0 91 c9 01 	lds	r31, 0x01C9	; 0x8001c9 <lastByte.2045+0x1>
     676:	20 91 ca 01 	lds	r18, 0x01CA	; 0x8001ca <posistionWithinByte.2046>
     67a:	80 91 c3 01 	lds	r24, 0x01C3	; 0x8001c3 <readBit.2049>
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	02 2e       	mov	r0, r18
     682:	02 c0       	rjmp	.+4      	; 0x688 <readByteFromOneWireBus+0x40>
     684:	88 0f       	add	r24, r24
     686:	99 1f       	adc	r25, r25
     688:	0a 94       	dec	r0
     68a:	e2 f7       	brpl	.-8      	; 0x684 <readByteFromOneWireBus+0x3c>
     68c:	90 81       	ld	r25, Z
     68e:	89 2b       	or	r24, r25
     690:	80 83       	st	Z, r24
		posistionWithinByte++;
     692:	81 e0       	ldi	r24, 0x01	; 1
     694:	82 0f       	add	r24, r18
     696:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <posistionWithinByte.2046>
	}
	
	if (posistionWithinByte < BITS_PER_BYTE)
     69a:	88 30       	cpi	r24, 0x08	; 8
     69c:	50 f4       	brcc	.+20     	; 0x6b2 <readByteFromOneWireBus+0x6a>
		readBitFromOneWire(lastOneWirePin, &readBit, &readNextBitWrapper);
     69e:	4f e5       	ldi	r20, 0x5F	; 95
     6a0:	53 e0       	ldi	r21, 0x03	; 3
     6a2:	63 ec       	ldi	r22, 0xC3	; 195
     6a4:	71 e0       	ldi	r23, 0x01	; 1
     6a6:	80 91 c4 01 	lds	r24, 0x01C4	; 0x8001c4 <lastOneWirePin.2048>
     6aa:	90 91 c5 01 	lds	r25, 0x01C5	; 0x8001c5 <lastOneWirePin.2048+0x1>
     6ae:	ca c0       	rjmp	.+404    	; 0x844 <readBitFromOneWire>
     6b0:	08 95       	ret
	else
		lastCallback();
     6b2:	e0 91 c6 01 	lds	r30, 0x01C6	; 0x8001c6 <lastCallback.2047>
     6b6:	f0 91 c7 01 	lds	r31, 0x01C7	; 0x8001c7 <lastCallback.2047+0x1>
     6ba:	09 95       	icall
     6bc:	08 95       	ret

000006be <readNextBitWrapper>:
	performFullOneWireReset(internalDataOneWireFrontend.onewirepin, &onReadyToSendSkipRomCommand);
}

void readNextBitWrapper(void)
{
	readByteFromOneWireBus(NULL, false, NULL, NULL);
     6be:	20 e0       	ldi	r18, 0x00	; 0
     6c0:	30 e0       	ldi	r19, 0x00	; 0
     6c2:	40 e0       	ldi	r20, 0x00	; 0
     6c4:	50 e0       	ldi	r21, 0x00	; 0
     6c6:	60 e0       	ldi	r22, 0x00	; 0
     6c8:	80 e0       	ldi	r24, 0x00	; 0
     6ca:	90 e0       	ldi	r25, 0x00	; 0
     6cc:	bd cf       	rjmp	.-134    	; 0x648 <readByteFromOneWireBus>
     6ce:	08 95       	ret

000006d0 <writeByteToOneWireBus>:
	static volatile CallbackFunctionType lastCallback;
	static const GPIOPin_t * lastOneWirePin;
	
	// if run the first time with startAtZero = false then this will produce undefined behavior
	// do not use the internalData data object here since this will be used by the other functions in the subordinate state machines!!
	if(startAtZero)
     6d0:	66 23       	and	r22, r22
     6d2:	61 f0       	breq	.+24     	; 0x6ec <writeByteToOneWireBus+0x1c>
	{
		positionWithinByte = 0;
     6d4:	10 92 c2 01 	sts	0x01C2, r1	; 0x8001c2 <positionWithinByte.2060>
		lastByte = byte;
     6d8:	80 93 c1 01 	sts	0x01C1, r24	; 0x8001c1 <lastByte.2059>
		lastCallback = onByteSent;
     6dc:	30 93 c0 01 	sts	0x01C0, r19	; 0x8001c0 <lastCallback.2061+0x1>
     6e0:	20 93 bf 01 	sts	0x01BF, r18	; 0x8001bf <lastCallback.2061>
		lastOneWirePin = onewirepin;
     6e4:	50 93 be 01 	sts	0x01BE, r21	; 0x8001be <lastOneWirePin.2062+0x1>
     6e8:	40 93 bd 01 	sts	0x01BD, r20	; 0x8001bd <lastOneWirePin.2062>
	}

	if (positionWithinByte < BITS_PER_BYTE)
     6ec:	80 91 c2 01 	lds	r24, 0x01C2	; 0x8001c2 <positionWithinByte.2060>
     6f0:	88 30       	cpi	r24, 0x08	; 8
     6f2:	e0 f4       	brcc	.+56     	; 0x72c <writeByteToOneWireBus+0x5c>
	{
		if(lastByte & (1<<(positionWithinByte++)))
     6f4:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <lastByte.2059>
     6f8:	20 91 c2 01 	lds	r18, 0x01C2	; 0x8001c2 <positionWithinByte.2060>
     6fc:	91 e0       	ldi	r25, 0x01	; 1
     6fe:	92 0f       	add	r25, r18
     700:	90 93 c2 01 	sts	0x01C2, r25	; 0x8001c2 <positionWithinByte.2060>
     704:	90 e0       	ldi	r25, 0x00	; 0
     706:	02 c0       	rjmp	.+4      	; 0x70c <writeByteToOneWireBus+0x3c>
     708:	95 95       	asr	r25
     70a:	87 95       	ror	r24
     70c:	2a 95       	dec	r18
     70e:	e2 f7       	brpl	.-8      	; 0x708 <writeByteToOneWireBus+0x38>
			write1BitToOneWire(lastOneWirePin, &writeNextBitWrapper);
     710:	67 ed       	ldi	r22, 0xD7	; 215
     712:	73 e0       	ldi	r23, 0x03	; 3
		lastOneWirePin = onewirepin;
	}

	if (positionWithinByte < BITS_PER_BYTE)
	{
		if(lastByte & (1<<(positionWithinByte++)))
     714:	80 ff       	sbrs	r24, 0
     716:	05 c0       	rjmp	.+10     	; 0x722 <writeByteToOneWireBus+0x52>
			write1BitToOneWire(lastOneWirePin, &writeNextBitWrapper);
     718:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <lastOneWirePin.2062>
     71c:	90 91 be 01 	lds	r25, 0x01BE	; 0x8001be <lastOneWirePin.2062+0x1>
     720:	cc c0       	rjmp	.+408    	; 0x8ba <write1BitToOneWire>
		else
			write0BitToOneWire(lastOneWirePin, &writeNextBitWrapper);
     722:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <lastOneWirePin.2062>
     726:	90 91 be 01 	lds	r25, 0x01BE	; 0x8001be <lastOneWirePin.2062+0x1>
     72a:	b4 c0       	rjmp	.+360    	; 0x894 <write0BitToOneWire>
	}
	else
	lastCallback();
     72c:	e0 91 bf 01 	lds	r30, 0x01BF	; 0x8001bf <lastCallback.2061>
     730:	f0 91 c0 01 	lds	r31, 0x01C0	; 0x8001c0 <lastCallback.2061+0x1>
     734:	09 94       	ijmp

00000736 <sendID>:

void sendID(IN_PAR const bool startAtZero)
{
	static volatile uint8_t positionWithinID;
	
	if(startAtZero)
     736:	81 11       	cpse	r24, r1
		positionWithinID=0;
     738:	10 92 cb 01 	sts	0x01CB, r1	; 0x8001cb <positionWithinID.2017>
	if (positionWithinID<SIZE_OF_ID)
     73c:	80 91 cb 01 	lds	r24, 0x01CB	; 0x8001cb <positionWithinID.2017>
     740:	88 30       	cpi	r24, 0x08	; 8
     742:	a8 f4       	brcc	.+42     	; 0x76e <sendID+0x38>
		writeByteToOneWireBus(internalDataOneWireFrontend.deviceId[positionWithinID++],true,internalDataOneWireFrontend.onewirepin,&sendNextIDByte);
     744:	e9 e0       	ldi	r30, 0x09	; 9
     746:	f6 e0       	ldi	r31, 0x06	; 6
     748:	42 81       	ldd	r20, Z+2	; 0x02
     74a:	53 81       	ldd	r21, Z+3	; 0x03
     74c:	01 90       	ld	r0, Z+
     74e:	f0 81       	ld	r31, Z
     750:	e0 2d       	mov	r30, r0
     752:	80 91 cb 01 	lds	r24, 0x01CB	; 0x8001cb <positionWithinID.2017>
     756:	91 e0       	ldi	r25, 0x01	; 1
     758:	98 0f       	add	r25, r24
     75a:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <positionWithinID.2017>
     75e:	e8 0f       	add	r30, r24
     760:	f1 1d       	adc	r31, r1
     762:	2d eb       	ldi	r18, 0xBD	; 189
     764:	33 e0       	ldi	r19, 0x03	; 3
     766:	61 e0       	ldi	r22, 0x01	; 1
     768:	80 81       	ld	r24, Z
     76a:	b2 cf       	rjmp	.-156    	; 0x6d0 <writeByteToOneWireBus>
     76c:	08 95       	ret
	else
		internalDataOneWireFrontend.callback();
     76e:	e0 91 0d 06 	lds	r30, 0x060D	; 0x80060d <internalDataOneWireFrontend+0x4>
     772:	f0 91 0e 06 	lds	r31, 0x060E	; 0x80060e <internalDataOneWireFrontend+0x5>
     776:	09 95       	icall
     778:	08 95       	ret

0000077a <sendNextIDByte>:

void sendID(IN_PAR const bool startAtZero);

void sendNextIDByte(void)
{
	sendID(false);
     77a:	80 e0       	ldi	r24, 0x00	; 0
     77c:	dc cf       	rjmp	.-72     	; 0x736 <sendID>
     77e:	08 95       	ret

00000780 <onMatchRomCommandSent>:
		internalDataOneWireFrontend.callback();
}

void onMatchRomCommandSent(void)
{
	sendID(true);
     780:	81 e0       	ldi	r24, 0x01	; 1
     782:	d9 cf       	rjmp	.-78     	; 0x736 <sendID>
     784:	08 95       	ret

00000786 <onReadyToSendMatchRomCommand>:
}

void onReadyToSendMatchRomCommand(void)
{
	writeByteToOneWireBus(OneWireRomCommands_MatchRom,true,internalDataOneWireFrontend.onewirepin, &onMatchRomCommandSent);
     786:	40 91 0b 06 	lds	r20, 0x060B	; 0x80060b <internalDataOneWireFrontend+0x2>
     78a:	50 91 0c 06 	lds	r21, 0x060C	; 0x80060c <internalDataOneWireFrontend+0x3>
     78e:	20 ec       	ldi	r18, 0xC0	; 192
     790:	33 e0       	ldi	r19, 0x03	; 3
     792:	61 e0       	ldi	r22, 0x01	; 1
     794:	85 e5       	ldi	r24, 0x55	; 85
     796:	9c cf       	rjmp	.-200    	; 0x6d0 <writeByteToOneWireBus>
     798:	08 95       	ret

0000079a <onReadyToSendSkipRomCommand>:
}

void onReadyToSendSkipRomCommand(void)
{
	writeByteToOneWireBus(OneWireRomCommands_SkipRom,true,internalDataOneWireFrontend.onewirepin, internalDataOneWireFrontend.callback);
     79a:	e9 e0       	ldi	r30, 0x09	; 9
     79c:	f6 e0       	ldi	r31, 0x06	; 6
     79e:	24 81       	ldd	r18, Z+4	; 0x04
     7a0:	35 81       	ldd	r19, Z+5	; 0x05
     7a2:	42 81       	ldd	r20, Z+2	; 0x02
     7a4:	53 81       	ldd	r21, Z+3	; 0x03
     7a6:	61 e0       	ldi	r22, 0x01	; 1
     7a8:	8c ec       	ldi	r24, 0xCC	; 204
     7aa:	92 cf       	rjmp	.-220    	; 0x6d0 <writeByteToOneWireBus>
     7ac:	08 95       	ret

000007ae <writeNextBitWrapper>:
		lastCallback();
}

void writeNextBitWrapper(void)
{
	writeByteToOneWireBus(0, false, NULL, NULL);
     7ae:	20 e0       	ldi	r18, 0x00	; 0
     7b0:	30 e0       	ldi	r19, 0x00	; 0
     7b2:	40 e0       	ldi	r20, 0x00	; 0
     7b4:	50 e0       	ldi	r21, 0x00	; 0
     7b6:	60 e0       	ldi	r22, 0x00	; 0
     7b8:	80 e0       	ldi	r24, 0x00	; 0
     7ba:	8a cf       	rjmp	.-236    	; 0x6d0 <writeByteToOneWireBus>
     7bc:	08 95       	ret

000007be <onReadBitEnsureLongEnoughIdleTime>:

volatile bool isDevicePresent=false;

void onReadBitEnsureLongEnoughIdleTime(void)
{
	stopTimer2();
     7be:	fb d2       	rcall	.+1526   	; 0xdb6 <stopTimer2>
	internalData.callback(); //onBitRead
     7c0:	e0 91 11 06 	lds	r30, 0x0611	; 0x800611 <internalData+0x2>
     7c4:	f0 91 12 06 	lds	r31, 0x0612	; 0x800612 <internalData+0x3>
     7c8:	09 95       	icall
     7ca:	08 95       	ret

000007cc <onWrite1BusIsSampled>:
	enableTimer2CaptureCompareAInterrupt();
}

void onWrite1BusIsSampled(void)
{
	stopTimer2();
     7cc:	f4 d2       	rcall	.+1512   	; 0xdb6 <stopTimer2>
	(internalData.callback)();
     7ce:	e0 91 11 06 	lds	r30, 0x0611	; 0x800611 <internalData+0x2>
     7d2:	f0 91 12 06 	lds	r31, 0x0612	; 0x800612 <internalData+0x3>
     7d6:	09 95       	icall
     7d8:	08 95       	ret

000007da <onResetPulse500usHaveElapsedEvent>:
	
	enableExternalInterrupt(onewirepin, ExternalInteruptPolarity_RisingEdge, &onPresencePulseEnded);
}

void onResetPulse500usHaveElapsedEvent(void)
{
     7da:	cf 93       	push	r28
     7dc:	df 93       	push	r29
	stopTimer2();
     7de:	eb d2       	rcall	.+1494   	; 0xdb6 <stopTimer2>
	makeInput(internalData.onewirepin);
     7e0:	cf e0       	ldi	r28, 0x0F	; 15
     7e2:	d6 e0       	ldi	r29, 0x06	; 6
     7e4:	88 81       	ld	r24, Y
     7e6:	99 81       	ldd	r25, Y+1	; 0x01
     7e8:	32 de       	rcall	.-924    	; 0x44e <makeInput>
	internalData.callback(); // on Reset Complete
     7ea:	ea 81       	ldd	r30, Y+2	; 0x02
     7ec:	fb 81       	ldd	r31, Y+3	; 0x03
     7ee:	09 95       	icall
}
     7f0:	df 91       	pop	r29
     7f2:	cf 91       	pop	r28
     7f4:	08 95       	ret

000007f6 <onWrite0BitBusMustGoHigh>:
	letTimer2GenerateInterruptEveryRoughly60us(); // ~60us until Interrupt; this makes me able to reuse the same code for the delay time and ensures that all read slots are definitely a minimum of 60us in duration...
	enableTimer2CaptureCompareAInterrupt();
}

void onWrite0BitBusMustGoHigh(void)
{
     7f6:	cf 93       	push	r28
     7f8:	df 93       	push	r29
	makeInput(internalData.onewirepin);
     7fa:	cf e0       	ldi	r28, 0x0F	; 15
     7fc:	d6 e0       	ldi	r29, 0x06	; 6
     7fe:	88 81       	ld	r24, Y
     800:	99 81       	ldd	r25, Y+1	; 0x01
     802:	25 de       	rcall	.-950    	; 0x44e <makeInput>
	stopTimer2();
     804:	d8 d2       	rcall	.+1456   	; 0xdb6 <stopTimer2>
     806:	8a e0       	ldi	r24, 0x0A	; 10
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     808:	8a 95       	dec	r24
     80a:	f1 f7       	brne	.-4      	; 0x808 <onWrite0BitBusMustGoHigh+0x12>
     80c:	00 c0       	rjmp	.+0      	; 0x80e <onWrite0BitBusMustGoHigh+0x18>
     80e:	ea 81       	ldd	r30, Y+2	; 0x02
	_delay_us(2); // after every write 0 the bus must be idle for more than 1us
	(internalData.callback)();
     810:	fb 81       	ldd	r31, Y+3	; 0x03
     812:	09 95       	icall
     814:	df 91       	pop	r29
}
     816:	cf 91       	pop	r28
     818:	08 95       	ret

0000081a <onPresencePulse500usHaveElapsedEvent>:
     81a:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <isDevicePresent>
	enableTimer2CaptureCompareAInterrupt(); // makes interrupt after ~60us then the Bus is sampled by the Slave device
}

void onPresencePulse500usHaveElapsedEvent(void)
{
	if (isDevicePresent)
     81e:	88 23       	and	r24, r24
     820:	31 f0       	breq	.+12     	; 0x82e <onPresencePulse500usHaveElapsedEvent+0x14>
		internalData.callback(); // onPresencePulseReceived
     822:	e0 91 11 06 	lds	r30, 0x0611	; 0x800611 <internalData+0x2>
     826:	f0 91 12 06 	lds	r31, 0x0612	; 0x800612 <internalData+0x3>
     82a:	09 95       	icall
     82c:	08 95       	ret
	else
		deathTrap();
     82e:	c9 ce       	rjmp	.-622    	; 0x5c2 <deathTrap>
     830:	08 95       	ret

00000832 <onPresencePulseEnded>:
}

void onPresencePulseEnded(void)
{
	disableExternalInterrupt(internalData.onewirepin);
     832:	80 91 0f 06 	lds	r24, 0x060F	; 0x80060f <internalData>
     836:	90 91 10 06 	lds	r25, 0x0610	; 0x800610 <internalData+0x1>
     83a:	7a de       	rcall	.-780    	; 0x530 <disableExternalInterrupt>
	isDevicePresent=true;
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <isDevicePresent>
     842:	08 95       	ret

00000844 <readBitFromOneWire>:
	stopTimer2();
	internalData.callback(); //onBitRead
}

void readBitFromOneWire(IN_PAR const GPIOPin_t * const onewirepin, OUT_PAR bool * const storeReadBitHere, IN_PAR const CallbackFunctionType onBitRead)
{
     844:	ef 92       	push	r14
     846:	ff 92       	push	r15
     848:	0f 93       	push	r16
     84a:	1f 93       	push	r17
     84c:	cf 93       	push	r28
     84e:	df 93       	push	r29
     850:	ec 01       	movw	r28, r24
     852:	7b 01       	movw	r14, r22
     854:	8a 01       	movw	r16, r20
	makeOutputLow(onewirepin); // initiates the read time slot
     856:	0f de       	rcall	.-994    	; 0x476 <makeOutputLow>
     858:	8a e0       	ldi	r24, 0x0A	; 10
     85a:	8a 95       	dec	r24
     85c:	f1 f7       	brne	.-4      	; 0x85a <readBitFromOneWire+0x16>
     85e:	00 c0       	rjmp	.+0      	; 0x860 <readBitFromOneWire+0x1c>
	_delay_us(2); // 2us; the bus must be low for more than 1us but less than 15us, no interrupts here because that is too slow
	makeInput(onewirepin);
     860:	ce 01       	movw	r24, r28
     862:	f5 dd       	rcall	.-1046   	; 0x44e <makeInput>
     864:	e5 e3       	ldi	r30, 0x35	; 53
     866:	ea 95       	dec	r30
     868:	f1 f7       	brne	.-4      	; 0x866 <readBitFromOneWire+0x22>
	_delay_us(10); // even that is still not that easy with interrupts; 10us because the bus must be sampled towards the end of the 15us readslot (2us+10us=12us<15us and near the end of the readslot)
	*storeReadBitHere = getPinState(onewirepin);
     86a:	00 00       	nop
     86c:	ce 01       	movw	r24, r28
     86e:	d8 dd       	rcall	.-1104   	; 0x420 <getPinState>
     870:	f7 01       	movw	r30, r14
     872:	80 83       	st	Z, r24
	// after every read 0 the bus must be idle for more than 1us. in read 1 case it does not really matter. but all read slots must be a minimum of 60us in duration
	internalData.callback = onBitRead;
     874:	10 93 12 06 	sts	0x0612, r17	; 0x800612 <internalData+0x3>
     878:	00 93 11 06 	sts	0x0611, r16	; 0x800611 <internalData+0x2>
	defineCallbackOnTimer2CaptureCompareAMatch(&onReadBitEnsureLongEnoughIdleTime);
     87c:	8f ed       	ldi	r24, 0xDF	; 223
	letTimer2GenerateInterruptEveryRoughly60us(); // ~60us until Interrupt; this makes me able to reuse the same code for the delay time and ensures that all read slots are definitely a minimum of 60us in duration...
     87e:	93 e0       	ldi	r25, 0x03	; 3
     880:	29 d2       	rcall	.+1106   	; 0xcd4 <defineCallbackOnTimer2CaptureCompareAMatch>
	enableTimer2CaptureCompareAInterrupt();
     882:	a4 d2       	rcall	.+1352   	; 0xdcc <letTimer2GenerateInterruptEveryRoughly60us>
     884:	a9 d2       	rcall	.+1362   	; 0xdd8 <enableTimer2CaptureCompareAInterrupt>
}
     886:	df 91       	pop	r29
     888:	cf 91       	pop	r28
     88a:	1f 91       	pop	r17
     88c:	0f 91       	pop	r16
     88e:	ff 90       	pop	r15
     890:	ef 90       	pop	r14
     892:	08 95       	ret

00000894 <write0BitToOneWire>:
	_delay_us(2); // after every write 0 the bus must be idle for more than 1us
	(internalData.callback)();
}

void write0BitToOneWire(IN_PAR const GPIOPin_t * const onewirepin,IN_PAR const CallbackFunctionType onBitWritten)
{
     894:	cf 93       	push	r28
     896:	df 93       	push	r29
     898:	ec 01       	movw	r28, r24
	internalData.onewirepin = onewirepin;
     89a:	ef e0       	ldi	r30, 0x0F	; 15
     89c:	f6 e0       	ldi	r31, 0x06	; 6
     89e:	91 83       	std	Z+1, r25	; 0x01
     8a0:	80 83       	st	Z, r24
	internalData.callback = onBitWritten;
     8a2:	73 83       	std	Z+3, r23	; 0x03
     8a4:	62 83       	std	Z+2, r22	; 0x02
	defineCallbackOnTimer2CaptureCompareAMatch(&onWrite0BitBusMustGoHigh);
     8a6:	8b ef       	ldi	r24, 0xFB	; 251
     8a8:	93 e0       	ldi	r25, 0x03	; 3
     8aa:	14 d2       	rcall	.+1064   	; 0xcd4 <defineCallbackOnTimer2CaptureCompareAMatch>
	letTimer2GenerateInterruptEveryRoughly60us(); // ~60us until Interrupt because the bus must be low for 60-120us
     8ac:	8f d2       	rcall	.+1310   	; 0xdcc <letTimer2GenerateInterruptEveryRoughly60us>
	makeOutputLow(onewirepin);
     8ae:	ce 01       	movw	r24, r28
     8b0:	e2 dd       	rcall	.-1084   	; 0x476 <makeOutputLow>
	enableTimer2CaptureCompareAInterrupt();
     8b2:	92 d2       	rcall	.+1316   	; 0xdd8 <enableTimer2CaptureCompareAInterrupt>
     8b4:	df 91       	pop	r29
}
     8b6:	cf 91       	pop	r28
     8b8:	08 95       	ret

000008ba <write1BitToOneWire>:
     8ba:	cf 93       	push	r28
	(internalData.callback)();
	// here there is no time delay needed as the bus is already quasi idle...
}

__attribute__((optimize("O3"))) void write1BitToOneWire(IN_PAR const GPIOPin_t * const onewirepin, IN_PAR const CallbackFunctionType onBitWritten) 
{
     8bc:	df 93       	push	r29
     8be:	ec 01       	movw	r28, r24
	internalData.onewirepin=onewirepin;
     8c0:	ef e0       	ldi	r30, 0x0F	; 15
     8c2:	f6 e0       	ldi	r31, 0x06	; 6
     8c4:	91 83       	std	Z+1, r25	; 0x01
     8c6:	80 83       	st	Z, r24
	internalData.callback=onBitWritten;
     8c8:	73 83       	std	Z+3, r23	; 0x03
     8ca:	62 83       	std	Z+2, r22	; 0x02
	makeOutputLow(onewirepin);
     8cc:	d4 dd       	rcall	.-1112   	; 0x476 <makeOutputLow>
     8ce:	85 e0       	ldi	r24, 0x05	; 5
     8d0:	8a 95       	dec	r24
     8d2:	f1 f7       	brne	.-4      	; 0x8d0 <write1BitToOneWire+0x16>
     8d4:	00 00       	nop
	// scope shows that delay does not really work and even a single nop does not help to get the low time below 1us so omit it entirely?!
	_delay_us(1); // after 1us the bus must go high again see Datasheet DS18B20 p.16/20 1us is too short for a Timer Interrupt
	makeInput(onewirepin);
     8d6:	ce 01       	movw	r24, r28
     8d8:	ba dd       	rcall	.-1164   	; 0x44e <makeInput>
	defineCallbackOnTimer2CaptureCompareAMatch(&onWrite1BusIsSampled);
     8da:	86 ee       	ldi	r24, 0xE6	; 230
     8dc:	93 e0       	ldi	r25, 0x03	; 3
	letTimer2GenerateInterruptEveryRoughly60us();
     8de:	fa d1       	rcall	.+1012   	; 0xcd4 <defineCallbackOnTimer2CaptureCompareAMatch>
	enableTimer2CaptureCompareAInterrupt(); // makes interrupt after ~60us then the Bus is sampled by the Slave device
}
     8e0:	75 d2       	rcall	.+1258   	; 0xdcc <letTimer2GenerateInterruptEveryRoughly60us>
     8e2:	df 91       	pop	r29
	// scope shows that delay does not really work and even a single nop does not help to get the low time below 1us so omit it entirely?!
	_delay_us(1); // after 1us the bus must go high again see Datasheet DS18B20 p.16/20 1us is too short for a Timer Interrupt
	makeInput(onewirepin);
	defineCallbackOnTimer2CaptureCompareAMatch(&onWrite1BusIsSampled);
	letTimer2GenerateInterruptEveryRoughly60us();
	enableTimer2CaptureCompareAInterrupt(); // makes interrupt after ~60us then the Bus is sampled by the Slave device
     8e4:	cf 91       	pop	r28
     8e6:	78 c2       	rjmp	.+1264   	; 0xdd8 <enableTimer2CaptureCompareAInterrupt>

000008e8 <awaitOneWirePresencePulse>:
	disableExternalInterrupt(internalData.onewirepin);
	isDevicePresent=true;
}

void awaitOneWirePresencePulse(IN_PAR const GPIOPin_t * const onewirepin,IN_PAR CallbackFunctionType onPresencePulseReceived)
{
     8e8:	cf 93       	push	r28
     8ea:	df 93       	push	r29
     8ec:	ec 01       	movw	r28, r24
	
		DS18B20 Datasheet p.15/20 
		
		External Interrupts appear to be too slow to detect the presence pulse's falling edge. But the Rising Edge works out just fine.
	*/
	internalData.onewirepin = onewirepin;
     8ee:	ef e0       	ldi	r30, 0x0F	; 15
     8f0:	f6 e0       	ldi	r31, 0x06	; 6
     8f2:	91 83       	std	Z+1, r25	; 0x01
     8f4:	80 83       	st	Z, r24
	internalData.callback = onPresencePulseReceived;
     8f6:	73 83       	std	Z+3, r23	; 0x03
     8f8:	62 83       	std	Z+2, r22	; 0x02
		
	defineCallbackOnTimer2CaptureCompareAMatch(&onPresencePulse500usHaveElapsedEvent); // ensure long enough waiting period since the master has to RX for at least 480us
     8fa:	8d e0       	ldi	r24, 0x0D	; 13
     8fc:	94 e0       	ldi	r25, 0x04	; 4
     8fe:	ea d1       	rcall	.+980    	; 0xcd4 <defineCallbackOnTimer2CaptureCompareAMatch>
	letTimer2GenerateInterruptEvery500us();
     900:	5f d2       	rcall	.+1214   	; 0xdc0 <letTimer2GenerateInterruptEvery500us>
	enableTimer2CaptureCompareAInterrupt();
     902:	6a d2       	rcall	.+1236   	; 0xdd8 <enableTimer2CaptureCompareAInterrupt>

	bool isEdgeFalling=false;
	// bus is high
	while(!isEdgeFalling)
	{
		if(getPinState(onewirepin) == false)
     904:	ce 01       	movw	r24, r28
     906:	8c dd       	rcall	.-1256   	; 0x420 <getPinState>
     908:	81 11       	cpse	r24, r1
     90a:	fc cf       	rjmp	.-8      	; 0x904 <__stack+0x5>
     90c:	49 e1       	ldi	r20, 0x19	; 25
			isEdgeFalling = true;
	}// loop detects falling edge, polling since using interrupts did not work out here 
	
	enableExternalInterrupt(onewirepin, ExternalInteruptPolarity_RisingEdge, &onPresencePulseEnded);
     90e:	54 e0       	ldi	r21, 0x04	; 4
     910:	63 e0       	ldi	r22, 0x03	; 3
     912:	ce 01       	movw	r24, r28
     914:	e1 dd       	rcall	.-1086   	; 0x4d8 <enableExternalInterrupt>
     916:	df 91       	pop	r29
}
     918:	cf 91       	pop	r28
     91a:	08 95       	ret

0000091c <awaitOneWirePresencePulseWrapper>:
     91c:	e4 e1       	ldi	r30, 0x14	; 20
	enableTimer2CaptureCompareAInterrupt();
}

void awaitOneWirePresencePulseWrapper(void)
{
	awaitOneWirePresencePulse(internalDataFullReset.onewirepin, internalDataFullReset.callback);
     91e:	f6 e0       	ldi	r31, 0x06	; 6
     920:	62 81       	ldd	r22, Z+2	; 0x02
     922:	73 81       	ldd	r23, Z+3	; 0x03
     924:	80 81       	ld	r24, Z
     926:	91 81       	ldd	r25, Z+1	; 0x01
     928:	df cf       	rjmp	.-66     	; 0x8e8 <awaitOneWirePresencePulse>
     92a:	08 95       	ret

0000092c <performOneWireReset>:
	makeInput(internalData.onewirepin);
	internalData.callback(); // on Reset Complete
}

void performOneWireReset(IN_PAR const GPIOPin_t * const onewirepin, IN_PAR const CallbackFunctionType onResetComplete)
{
     92c:	cf 93       	push	r28
     92e:	df 93       	push	r29
     930:	ec 01       	movw	r28, r24
	isDevicePresent=false;
     932:	10 92 cc 01 	sts	0x01CC, r1	; 0x8001cc <isDevicePresent>
	internalData.onewirepin = onewirepin;
     936:	ef e0       	ldi	r30, 0x0F	; 15
     938:	f6 e0       	ldi	r31, 0x06	; 6
     93a:	91 83       	std	Z+1, r25	; 0x01
     93c:	80 83       	st	Z, r24
	internalData.callback = onResetComplete;
     93e:	73 83       	std	Z+3, r23	; 0x03
     940:	62 83       	std	Z+2, r22	; 0x02
	
	defineCallbackOnTimer2CaptureCompareAMatch(&onResetPulse500usHaveElapsedEvent);
     942:	8d ee       	ldi	r24, 0xED	; 237
     944:	93 e0       	ldi	r25, 0x03	; 3
     946:	c6 d1       	rcall	.+908    	; 0xcd4 <defineCallbackOnTimer2CaptureCompareAMatch>
	makeOutputLow(onewirepin);
     948:	ce 01       	movw	r24, r28
	/*
		If the bus is held low for more than 480s, all components on the bus will	be reset.
		
		DS18B20 Datasheet p.10/20
	*/
	letTimer2GenerateInterruptEvery500us();
     94a:	95 dd       	rcall	.-1238   	; 0x476 <makeOutputLow>
     94c:	39 d2       	rcall	.+1138   	; 0xdc0 <letTimer2GenerateInterruptEvery500us>
	enableTimer2CaptureCompareAInterrupt();
     94e:	44 d2       	rcall	.+1160   	; 0xdd8 <enableTimer2CaptureCompareAInterrupt>
     950:	df 91       	pop	r29
}
     952:	cf 91       	pop	r28
     954:	08 95       	ret

00000956 <performFullOneWireReset>:
     956:	e4 e1       	ldi	r30, 0x14	; 20
	awaitOneWirePresencePulse(internalDataFullReset.onewirepin, internalDataFullReset.callback);
}

void performFullOneWireReset(IN_PAR const GPIOPin_t * const onewirepin, IN_PAR const CallbackFunctionType onFullResetComplete)
{
	internalDataFullReset.onewirepin = onewirepin;
     958:	f6 e0       	ldi	r31, 0x06	; 6
     95a:	91 83       	std	Z+1, r25	; 0x01
     95c:	80 83       	st	Z, r24
	internalDataFullReset.callback = onFullResetComplete;
     95e:	73 83       	std	Z+3, r23	; 0x03
     960:	62 83       	std	Z+2, r22	; 0x02
	performOneWireReset(onewirepin,&awaitOneWirePresencePulseWrapper);
     962:	6e e8       	ldi	r22, 0x8E	; 142
     964:	74 e0       	ldi	r23, 0x04	; 4
     966:	e2 cf       	rjmp	.-60     	; 0x92c <performOneWireReset>
     968:	08 95       	ret

0000096a <onTemperatureRead>:
	}
}

void onTemperatureRead(void)
{
	issueTemperatureConversion(&onewirepin,false,deviceIDs[indexOfTemperatureSensorBeingRead], &onTemperatureConversionStarted);
     96a:	e0 91 cd 01 	lds	r30, 0x01CD	; 0x8001cd <indexOfTemperatureSensorBeingRead>
     96e:	f0 e0       	ldi	r31, 0x00	; 0
     970:	ee 0f       	add	r30, r30
     972:	ff 1f       	adc	r31, r31
     974:	e8 5f       	subi	r30, 0xF8	; 248
     976:	fe 4f       	sbci	r31, 0xFE	; 254
     978:	40 81       	ld	r20, Z
     97a:	51 81       	ldd	r21, Z+1	; 0x01
     97c:	2d e7       	ldi	r18, 0x7D	; 125
     97e:	35 e0       	ldi	r19, 0x05	; 5
     980:	60 e0       	ldi	r22, 0x00	; 0
     982:	8e e1       	ldi	r24, 0x1E	; 30
     984:	91 e0       	ldi	r25, 0x01	; 1
     986:	70 cc       	rjmp	.-1824   	; 0x268 <issueTemperatureConversion>
     988:	08 95       	ret

0000098a <onAllTemperaturesRead>:

uint8_t indexOfTemperatureSensorBeingRead=0;

void onAllTemperaturesRead(void)
{
	__asm("nop\r\n");
     98a:	00 00       	nop
     98c:	08 95       	ret

0000098e <sendTelemetryViaUSART0>:
}

void sendTelemetryViaUSART0(void)
{
     98e:	0f 93       	push	r16
     990:	1f 93       	push	r17
     992:	cf 93       	push	r28
     994:	df 93       	push	r29
	signed7Point4Fixed_t currentTemperature = currentTemperatures[indexOfTemperatureSensorBeingRead];
     996:	80 91 cd 01 	lds	r24, 0x01CD	; 0x8001cd <indexOfTemperatureSensorBeingRead>
     99a:	90 e0       	ldi	r25, 0x00	; 0
     99c:	88 0f       	add	r24, r24
     99e:	99 1f       	adc	r25, r25
     9a0:	fc 01       	movw	r30, r24
     9a2:	ea 52       	subi	r30, 0x2A	; 42
     9a4:	fe 4f       	sbci	r31, 0xFE	; 254
     9a6:	c0 81       	ld	r28, Z
     9a8:	d1 81       	ldd	r29, Z+1	; 0x01

	char sign='?'; // some easy to tell apart from real data defaults that should be overwritten anyways
	uint8_t intPart=255;
	uint16_t nonIntPart=65535;

	if (deviceIDs[indexOfTemperatureSensorBeingRead][0]==FAMILY_CODE_DS18B20)
     9aa:	fc 01       	movw	r30, r24
     9ac:	e8 5f       	subi	r30, 0xF8	; 248
     9ae:	fe 4f       	sbci	r31, 0xFE	; 254
     9b0:	01 90       	ld	r0, Z+
     9b2:	f0 81       	ld	r31, Z
     9b4:	e0 2d       	mov	r30, r0
     9b6:	80 81       	ld	r24, Z
     9b8:	88 32       	cpi	r24, 0x28	; 40
     9ba:	49 f4       	brne	.+18     	; 0x9ce <sendTelemetryViaUSART0+0x40>
	{	
		sign = getSignOfSigned7Point4Fixed(currentTemperature);
     9bc:	ce 01       	movw	r24, r28
     9be:	e9 dc       	rcall	.-1582   	; 0x392 <getSignOfSigned7Point4Fixed>
     9c0:	18 2f       	mov	r17, r24
		intPart = getIntegerPartOfSigned7Point4Fixed(currentTemperature);
     9c2:	ce 01       	movw	r24, r28
     9c4:	ee dc       	rcall	.-1572   	; 0x3a2 <getIntegerPartOfSigned7Point4Fixed>
     9c6:	08 2f       	mov	r16, r24
		nonIntPart = getNonIntegerPartOfSigned7Point4Fixed(currentTemperature);
     9c8:	ce 01       	movw	r24, r28
     9ca:	f8 dc       	rcall	.-1552   	; 0x3bc <getNonIntegerPartOfSigned7Point4Fixed>
     9cc:	10 c0       	rjmp	.+32     	; 0x9ee <sendTelemetryViaUSART0+0x60>
     9ce:	8b 33       	cpi	r24, 0x3B	; 59
	}
	else if(deviceIDs[indexOfTemperatureSensorBeingRead][0]==FAMILY_CODE_MAX31850)
     9d0:	49 f4       	brne	.+18     	; 0x9e4 <sendTelemetryViaUSART0+0x56>
	{
		sign = getSignOfSigned11Point2Fixed(currentTemperature);
     9d2:	ce 01       	movw	r24, r28
     9d4:	f8 dd       	rcall	.-1040   	; 0x5c6 <getSignOfSigned11Point2Fixed>
     9d6:	18 2f       	mov	r17, r24
		intPart = getIntegerPartOfSigned11Point2Fixed(currentTemperature);
     9d8:	ce 01       	movw	r24, r28
     9da:	fb dd       	rcall	.-1034   	; 0x5d2 <getIntegerPartOfSigned11Point2Fixed>
		nonIntPart = getNonIntegerPartOfSigned11Point2Fixed(currentTemperature);
     9dc:	08 2f       	mov	r16, r24
     9de:	ce 01       	movw	r24, r28
     9e0:	08 de       	rcall	.-1008   	; 0x5f2 <getNonIntegerPartOfSigned11Point2Fixed>
     9e2:	05 c0       	rjmp	.+10     	; 0x9ee <sendTelemetryViaUSART0+0x60>
	}
	else
	{
		deathTrap(); // can not process because then sign intPart and nonIntPart would end up being uninitialized...
     9e4:	ee dd       	rcall	.-1060   	; 0x5c2 <deathTrap>
     9e6:	8f ef       	ldi	r24, 0xFF	; 255
{
	signed7Point4Fixed_t currentTemperature = currentTemperatures[indexOfTemperatureSensorBeingRead];

	char sign='?'; // some easy to tell apart from real data defaults that should be overwritten anyways
	uint8_t intPart=255;
	uint16_t nonIntPart=65535;
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	0f ef       	ldi	r16, 0xFF	; 255
void sendTelemetryViaUSART0(void)
{
	signed7Point4Fixed_t currentTemperature = currentTemperatures[indexOfTemperatureSensorBeingRead];

	char sign='?'; // some easy to tell apart from real data defaults that should be overwritten anyways
	uint8_t intPart=255;
     9ec:	1f e3       	ldi	r17, 0x3F	; 63

void sendTelemetryViaUSART0(void)
{
	signed7Point4Fixed_t currentTemperature = currentTemperatures[indexOfTemperatureSensorBeingRead];

	char sign='?'; // some easy to tell apart from real data defaults that should be overwritten anyways
     9ee:	20 91 cd 01 	lds	r18, 0x01CD	; 0x8001cd <indexOfTemperatureSensorBeingRead>
		deathTrap(); // can not process because then sign intPart and nonIntPart would end up being uninitialized...
	}
	
	#define TELEMETRY_STRING_SIZE_MAX (sizeof('#')+2+sizeof(':')+1+3+sizeof('.')+4+strlen("degC ")+strlen("Err: ")+1+strlen("\r\n")+sizeof('\0')) /*1st 2 digits for the number 1st 1 for the sign 3 for the int 4 for the fraction +1 for the error bit*/
	
	sprintf(telemetryString, "#%2i:%c%3i.%04idegC Err: %c\r\n",indexOfTemperatureSensorBeingRead, sign, intPart, nonIntPart, errorBits[indexOfTemperatureSensorBeingRead]?'E':'0');
     9f2:	e2 2f       	mov	r30, r18
     9f4:	f0 e0       	ldi	r31, 0x00	; 0
     9f6:	e7 5e       	subi	r30, 0xE7	; 231
     9f8:	f9 4f       	sbci	r31, 0xF9	; 249
     9fa:	30 81       	ld	r19, Z
     9fc:	31 11       	cpse	r19, r1
     9fe:	03 c0       	rjmp	.+6      	; 0xa06 <sendTelemetryViaUSART0+0x78>
     a00:	30 e3       	ldi	r19, 0x30	; 48
     a02:	40 e0       	ldi	r20, 0x00	; 0
     a04:	02 c0       	rjmp	.+4      	; 0xa0a <sendTelemetryViaUSART0+0x7c>
     a06:	35 e4       	ldi	r19, 0x45	; 69
     a08:	40 e0       	ldi	r20, 0x00	; 0
     a0a:	4f 93       	push	r20
     a0c:	3f 93       	push	r19
     a0e:	9f 93       	push	r25
     a10:	8f 93       	push	r24
     a12:	1f 92       	push	r1
     a14:	0f 93       	push	r16
     a16:	1f 92       	push	r1
     a18:	1f 93       	push	r17
     a1a:	1f 92       	push	r1
     a1c:	2f 93       	push	r18
     a1e:	86 e2       	ldi	r24, 0x26	; 38
     a20:	91 e0       	ldi	r25, 0x01	; 1
     a22:	9f 93       	push	r25
     a24:	8f 93       	push	r24
     a26:	80 91 d5 01 	lds	r24, 0x01D5	; 0x8001d5 <telemetryString+0x1>
     a2a:	8f 93       	push	r24
     a2c:	80 91 d4 01 	lds	r24, 0x01D4	; 0x8001d4 <telemetryString>
     a30:	8f 93       	push	r24
     a32:	b3 d3       	rcall	.+1894   	; 0x119a <sprintf>
     a34:	80 91 d4 01 	lds	r24, 0x01D4	; 0x8001d4 <telemetryString>
	USART0_SendString(telemetryString, strlen(telemetryString)); 
     a38:	90 91 d5 01 	lds	r25, 0x01D5	; 0x8001d5 <telemetryString+0x1>
     a3c:	fc 01       	movw	r30, r24
     a3e:	01 90       	ld	r0, Z+
     a40:	00 20       	and	r0, r0
     a42:	e9 f7       	brne	.-6      	; 0xa3e <sendTelemetryViaUSART0+0xb0>
     a44:	31 97       	sbiw	r30, 0x01	; 1
     a46:	bf 01       	movw	r22, r30
     a48:	68 1b       	sub	r22, r24
     a4a:	79 0b       	sbc	r23, r25
     a4c:	31 d2       	rcall	.+1122   	; 0xeb0 <USART0_SendString>
     a4e:	8d b7       	in	r24, 0x3d	; 61
}
     a50:	9e b7       	in	r25, 0x3e	; 62
     a52:	0e 96       	adiw	r24, 0x0e	; 14
     a54:	0f b6       	in	r0, 0x3f	; 63
     a56:	f8 94       	cli
     a58:	9e bf       	out	0x3e, r25	; 62
     a5a:	0f be       	out	0x3f, r0	; 63
     a5c:	8d bf       	out	0x3d, r24	; 61
     a5e:	df 91       	pop	r29
     a60:	cf 91       	pop	r28
     a62:	1f 91       	pop	r17
     a64:	0f 91       	pop	r16
     a66:	08 95       	ret

00000a68 <startTemperatureConversionAndReadoutCycle>:
     a68:	0f 93       	push	r16
{
	issueTemperatureConversion(&onewirepin,false,deviceIDs[indexOfTemperatureSensorBeingRead], &onTemperatureConversionStarted);
}

void startTemperatureConversionAndReadoutCycle(void)
{	
     a6a:	1f 93       	push	r17
	// start reading out the first sensor. when reading the very first time the contents read may be garbage.
	errorBits[indexOfTemperatureSensorBeingRead]=true; // reset the error bit before reading data again so that per default data is being treated as faulty (paranoid mode)
     a6c:	80 91 cd 01 	lds	r24, 0x01CD	; 0x8001cd <indexOfTemperatureSensorBeingRead>
     a70:	90 e0       	ldi	r25, 0x00	; 0
     a72:	9c 01       	movw	r18, r24
     a74:	27 5e       	subi	r18, 0xE7	; 231
     a76:	39 4f       	sbci	r19, 0xF9	; 249
     a78:	41 e0       	ldi	r20, 0x01	; 1
     a7a:	f9 01       	movw	r30, r18
     a7c:	40 83       	st	Z, r20
	readTemperature(&onewirepin,deviceIDs[indexOfTemperatureSensorBeingRead],&currentTemperatures[indexOfTemperatureSensorBeingRead], &errorBits[indexOfTemperatureSensorBeingRead], &onTemperatureRead);
     a7e:	88 0f       	add	r24, r24
     a80:	99 1f       	adc	r25, r25
     a82:	ac 01       	movw	r20, r24
     a84:	4a 52       	subi	r20, 0x2A	; 42
     a86:	5e 4f       	sbci	r21, 0xFE	; 254
     a88:	fc 01       	movw	r30, r24
     a8a:	e8 5f       	subi	r30, 0xF8	; 248
     a8c:	fe 4f       	sbci	r31, 0xFE	; 254
     a8e:	60 81       	ld	r22, Z
     a90:	71 81       	ldd	r23, Z+1	; 0x01
     a92:	05 eb       	ldi	r16, 0xB5	; 181
     a94:	14 e0       	ldi	r17, 0x04	; 4
     a96:	8e e1       	ldi	r24, 0x1E	; 30
     a98:	91 e0       	ldi	r25, 0x01	; 1
     a9a:	fc db       	rcall	.-2056   	; 0x294 <readTemperature>
}
     a9c:	1f 91       	pop	r17
     a9e:	0f 91       	pop	r16
     aa0:	08 95       	ret

00000aa2 <onOneSecondHasElapsedEvent>:

void startTemperatureConversionAndReadoutCycle(void);

void onOneSecondHasElapsedEvent(void)
{
	uptimeInSeconds++;
     aa2:	80 91 ce 01 	lds	r24, 0x01CE	; 0x8001ce <uptimeInSeconds>
     aa6:	90 91 cf 01 	lds	r25, 0x01CF	; 0x8001cf <uptimeInSeconds+0x1>
     aaa:	a0 91 d0 01 	lds	r26, 0x01D0	; 0x8001d0 <uptimeInSeconds+0x2>
     aae:	b0 91 d1 01 	lds	r27, 0x01D1	; 0x8001d1 <uptimeInSeconds+0x3>
     ab2:	01 96       	adiw	r24, 0x01	; 1
     ab4:	a1 1d       	adc	r26, r1
     ab6:	b1 1d       	adc	r27, r1
     ab8:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <uptimeInSeconds>
     abc:	90 93 cf 01 	sts	0x01CF, r25	; 0x8001cf <uptimeInSeconds+0x1>
     ac0:	a0 93 d0 01 	sts	0x01D0, r26	; 0x8001d0 <uptimeInSeconds+0x2>
     ac4:	b0 93 d1 01 	sts	0x01D1, r27	; 0x8001d1 <uptimeInSeconds+0x3>
	startTemperatureConversionAndReadoutCycle();
     ac8:	cf cf       	rjmp	.-98     	; 0xa68 <startTemperatureConversionAndReadoutCycle>
     aca:	08 95       	ret

00000acc <timingGeneratorForOneSecond>:

void timingGeneratorForOneSecond(void)
{
	static uint16_t remainingNumberOfInterruptsForOneSecond = REMAININGNUMBEROFINTERRUPTSFORONESECONDSTARTVALUE;
	
	if(remainingNumberOfInterruptsForOneSecond == 0)
     acc:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <remainingNumberOfInterruptsForOneSecond.2619>
     ad0:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <remainingNumberOfInterruptsForOneSecond.2619+0x1>
     ad4:	89 2b       	or	r24, r25
     ad6:	39 f4       	brne	.+14     	; 0xae6 <timingGeneratorForOneSecond+0x1a>
	{
		remainingNumberOfInterruptsForOneSecond = REMAININGNUMBEROFINTERRUPTSFORONESECONDSTARTVALUE;
     ad8:	80 ed       	ldi	r24, 0xD0	; 208
     ada:	97 e0       	ldi	r25, 0x07	; 7
     adc:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <remainingNumberOfInterruptsForOneSecond.2619+0x1>
     ae0:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <remainingNumberOfInterruptsForOneSecond.2619>
		onOneSecondHasElapsedEvent();
     ae4:	de df       	rcall	.-68     	; 0xaa2 <onOneSecondHasElapsedEvent>
	}
	remainingNumberOfInterruptsForOneSecond--;
     ae6:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <remainingNumberOfInterruptsForOneSecond.2619>
     aea:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <remainingNumberOfInterruptsForOneSecond.2619+0x1>
     aee:	01 97       	sbiw	r24, 0x01	; 1
     af0:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <remainingNumberOfInterruptsForOneSecond.2619+0x1>
     af4:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <remainingNumberOfInterruptsForOneSecond.2619>
     af8:	08 95       	ret

00000afa <onTemperatureConversionStarted>:
	USART0_SendString(telemetryString, strlen(telemetryString)); 
}

void onTemperatureConversionStarted(void)
{
	if(indexOfTemperatureSensorBeingRead<NUM_OF_ONEWIRE_SENSORS_ATTACHED-1) // if there is a next sensor to read out send telemetry of current sensor, increment counter and do the cycle for the next sensor
     afa:	80 91 cd 01 	lds	r24, 0x01CD	; 0x8001cd <indexOfTemperatureSensorBeingRead>
     afe:	8a 30       	cpi	r24, 0x0A	; 10
     b00:	40 f4       	brcc	.+16     	; 0xb12 <onTemperatureConversionStarted+0x18>
	{
		sendTelemetryViaUSART0();
     b02:	45 df       	rcall	.-374    	; 0x98e <sendTelemetryViaUSART0>
		indexOfTemperatureSensorBeingRead++;
     b04:	80 91 cd 01 	lds	r24, 0x01CD	; 0x8001cd <indexOfTemperatureSensorBeingRead>
     b08:	8f 5f       	subi	r24, 0xFF	; 255
     b0a:	80 93 cd 01 	sts	0x01CD, r24	; 0x8001cd <indexOfTemperatureSensorBeingRead>
		startTemperatureConversionAndReadoutCycle(); // read the next sensor
     b0e:	ac cf       	rjmp	.-168    	; 0xa68 <startTemperatureConversionAndReadoutCycle>
	}
	else // if there is no next sensor send telemetry of current sensor anyways and reset everything so the whole cycle can repeat for all the sensors some time in the future
	{
		sendTelemetryViaUSART0();
     b10:	08 95       	ret
     b12:	3d df       	rcall	.-390    	; 0x98e <sendTelemetryViaUSART0>
		USART0_SendString("\r\n\r\n",strlen("\r\n\r\n"));
     b14:	64 e0       	ldi	r22, 0x04	; 4
     b16:	84 e4       	ldi	r24, 0x44	; 68
     b18:	91 e0       	ldi	r25, 0x01	; 1
     b1a:	ca d1       	rcall	.+916    	; 0xeb0 <USART0_SendString>
		#define UPTIME_STRING_SIZE_MAX (strlen("!!Uptime [s]= ")+10+strlen(" \r\n")) /*10 is the amount of digits needed to display 2^32*/
		sprintf(uptimeString, "!!Uptime [s]= %-10i \r\n", uptimeInSeconds);
     b1c:	80 91 ce 01 	lds	r24, 0x01CE	; 0x8001ce <uptimeInSeconds>
     b20:	90 91 cf 01 	lds	r25, 0x01CF	; 0x8001cf <uptimeInSeconds+0x1>
     b24:	a0 91 d0 01 	lds	r26, 0x01D0	; 0x8001d0 <uptimeInSeconds+0x2>
     b28:	b0 91 d1 01 	lds	r27, 0x01D1	; 0x8001d1 <uptimeInSeconds+0x3>
     b2c:	bf 93       	push	r27
     b2e:	af 93       	push	r26
     b30:	9f 93       	push	r25
     b32:	8f 93       	push	r24
     b34:	89 e4       	ldi	r24, 0x49	; 73
     b36:	91 e0       	ldi	r25, 0x01	; 1
     b38:	9f 93       	push	r25
     b3a:	8f 93       	push	r24
     b3c:	80 91 d3 01 	lds	r24, 0x01D3	; 0x8001d3 <uptimeString+0x1>
     b40:	8f 93       	push	r24
     b42:	80 91 d2 01 	lds	r24, 0x01D2	; 0x8001d2 <uptimeString>
     b46:	8f 93       	push	r24
     b48:	28 d3       	rcall	.+1616   	; 0x119a <sprintf>
		USART0_SendString(uptimeString,strlen(uptimeString));
     b4a:	80 91 d2 01 	lds	r24, 0x01D2	; 0x8001d2 <uptimeString>
     b4e:	90 91 d3 01 	lds	r25, 0x01D3	; 0x8001d3 <uptimeString+0x1>
     b52:	fc 01       	movw	r30, r24
     b54:	01 90       	ld	r0, Z+
     b56:	00 20       	and	r0, r0
     b58:	e9 f7       	brne	.-6      	; 0xb54 <onTemperatureConversionStarted+0x5a>
     b5a:	31 97       	sbiw	r30, 0x01	; 1
     b5c:	bf 01       	movw	r22, r30
     b5e:	68 1b       	sub	r22, r24
     b60:	79 0b       	sbc	r23, r25
		indexOfTemperatureSensorBeingRead=0;
     b62:	a6 d1       	rcall	.+844    	; 0xeb0 <USART0_SendString>
     b64:	10 92 cd 01 	sts	0x01CD, r1	; 0x8001cd <indexOfTemperatureSensorBeingRead>
		onAllTemperaturesRead();
     b68:	10 df       	rcall	.-480    	; 0x98a <onAllTemperaturesRead>
     b6a:	8d b7       	in	r24, 0x3d	; 61
     b6c:	9e b7       	in	r25, 0x3e	; 62
     b6e:	08 96       	adiw	r24, 0x08	; 8
     b70:	0f b6       	in	r0, 0x3f	; 63
     b72:	f8 94       	cli
     b74:	9e bf       	out	0x3e, r25	; 62
     b76:	0f be       	out	0x3f, r0	; 63
     b78:	8d bf       	out	0x3d, r24	; 61
     b7a:	08 95       	ret

00000b7c <mainInit>:
	readTemperature(&onewirepin,deviceIDs[indexOfTemperatureSensorBeingRead],&currentTemperatures[indexOfTemperatureSensorBeingRead], &errorBits[indexOfTemperatureSensorBeingRead], &onTemperatureRead);
}

__attribute__((constructor)) void mainInit(void)
{
	makeInput(&onewirepin);
     b7c:	8e e1       	ldi	r24, 0x1E	; 30
     b7e:	91 e0       	ldi	r25, 0x01	; 1
     b80:	66 dc       	rcall	.-1844   	; 0x44e <makeInput>
	disablePullup(&onewirepin);
     b82:	8e e1       	ldi	r24, 0x1E	; 30
     b84:	91 e0       	ldi	r25, 0x01	; 1
     b86:	93 dc       	rcall	.-1754   	; 0x4ae <disablePullup>
	
	USART0_init(USARTBaudRate_9600);
     b88:	81 e0       	ldi	r24, 0x01	; 1
     b8a:	75 d1       	rcall	.+746    	; 0xe76 <USART0_init>
	
	telemetryString = malloc(TELEMETRY_STRING_SIZE_MAX);
     b8c:	8f e1       	ldi	r24, 0x1F	; 31
     b8e:	90 e0       	ldi	r25, 0x00	; 0
     b90:	e3 d1       	rcall	.+966    	; 0xf58 <malloc>
     b92:	90 93 d5 01 	sts	0x01D5, r25	; 0x8001d5 <telemetryString+0x1>
     b96:	80 93 d4 01 	sts	0x01D4, r24	; 0x8001d4 <telemetryString>
	uptimeString = malloc(UPTIME_STRING_SIZE_MAX);
     b9a:	8b e1       	ldi	r24, 0x1B	; 27
     b9c:	90 e0       	ldi	r25, 0x00	; 0
     b9e:	dc d1       	rcall	.+952    	; 0xf58 <malloc>
     ba0:	90 93 d3 01 	sts	0x01D3, r25	; 0x8001d3 <uptimeString+0x1>
     ba4:	80 93 d2 01 	sts	0x01D2, r24	; 0x8001d2 <uptimeString>
	
	setWaveformGenerationModeTimer0(WaveformGenerationModeTimer0_CTC); 
     ba8:	82 e0       	ldi	r24, 0x02	; 2
	defineCallbackOnTimer0CaptureCompareAMatch(&timingGeneratorForOneSecond);
     baa:	71 d0       	rcall	.+226    	; 0xc8e <setWaveformGenerationModeTimer0>
     bac:	86 e6       	ldi	r24, 0x66	; 102
     bae:	95 e0       	ldi	r25, 0x05	; 5
	letTimer0GenerateInterruptEvery500us();
     bb0:	1b d0       	rcall	.+54     	; 0xbe8 <defineCallbackOnTimer0CaptureCompareAMatch>
     bb2:	85 d0       	rcall	.+266    	; 0xcbe <letTimer0GenerateInterruptEvery500us>
	enableTimer0CaptureCompareAInterrupt();
     bb4:	89 d0       	rcall	.+274    	; 0xcc8 <enableTimer0CaptureCompareAInterrupt>
     bb6:	82 e0       	ldi	r24, 0x02	; 2
	
 	setWaveformGenerationModeTimer2(WaveformGenerationModeTimer2_CTC);// since the timer shall be reserved to the one wire functionality only these bits will only be set once and never changed again
     bb8:	e0 d0       	rcall	.+448    	; 0xd7a <setWaveformGenerationModeTimer2>
     bba:	10 92 ce 01 	sts	0x01CE, r1	; 0x8001ce <uptimeInSeconds>
	uptimeInSeconds=0;
     bbe:	10 92 cf 01 	sts	0x01CF, r1	; 0x8001cf <uptimeInSeconds+0x1>
     bc2:	10 92 d0 01 	sts	0x01D0, r1	; 0x8001d0 <uptimeInSeconds+0x2>
     bc6:	10 92 d1 01 	sts	0x01D1, r1	; 0x8001d1 <uptimeInSeconds+0x3>
     bca:	78 94       	sei
	sei();
     bcc:	4d cf       	rjmp	.-358    	; 0xa68 <startTemperatureConversionAndReadoutCycle>

	startTemperatureConversionAndReadoutCycle();
     bce:	08 95       	ret

00000bd0 <mainEnd>:
     bd0:	80 91 d4 01 	lds	r24, 0x01D4	; 0x8001d4 <telemetryString>
}

__attribute__((destructor)) void mainEnd(void)
{
	free(telemetryString);
     bd4:	90 91 d5 01 	lds	r25, 0x01D5	; 0x8001d5 <telemetryString+0x1>
     bd8:	57 d2       	rcall	.+1198   	; 0x1088 <free>
	free(uptimeString);
     bda:	80 91 d2 01 	lds	r24, 0x01D2	; 0x8001d2 <uptimeString>
     bde:	90 91 d3 01 	lds	r25, 0x01D3	; 0x8001d3 <uptimeString+0x1>
     be2:	52 c2       	rjmp	.+1188   	; 0x1088 <free>
     be4:	08 95       	ret

00000be6 <main>:
}

#pragma GCC diagnostic ignored "-Wmain"
void  __attribute__((noreturn)) main(void)
{
     be6:	ff cf       	rjmp	.-2      	; 0xbe6 <main>

00000be8 <defineCallbackOnTimer0CaptureCompareAMatch>:
}

void stopTimer0(void)
{
	setPrescalerTimer0(PrescalerTimer0_NoClockSource); // stops the timer
	TCNT0 = 0;
     be8:	90 93 27 06 	sts	0x0627, r25	; 0x800627 <onTimer0CaptureCompareAMatch+0x1>
     bec:	80 93 26 06 	sts	0x0626, r24	; 0x800626 <onTimer0CaptureCompareAMatch>
     bf0:	08 95       	ret

00000bf2 <__vector_16>:
     bf2:	1f 92       	push	r1
     bf4:	0f 92       	push	r0
     bf6:	0f b6       	in	r0, 0x3f	; 63
     bf8:	0f 92       	push	r0
     bfa:	11 24       	eor	r1, r1
     bfc:	2f 93       	push	r18
     bfe:	3f 93       	push	r19
     c00:	4f 93       	push	r20
     c02:	5f 93       	push	r21
     c04:	6f 93       	push	r22
     c06:	7f 93       	push	r23
     c08:	8f 93       	push	r24
     c0a:	9f 93       	push	r25
     c0c:	af 93       	push	r26
     c0e:	bf 93       	push	r27
     c10:	ef 93       	push	r30
     c12:	ff 93       	push	r31
     c14:	e0 91 24 06 	lds	r30, 0x0624	; 0x800624 <onTimer0Overflow>
     c18:	f0 91 25 06 	lds	r31, 0x0625	; 0x800625 <onTimer0Overflow+0x1>
     c1c:	09 95       	icall
     c1e:	ff 91       	pop	r31
     c20:	ef 91       	pop	r30
     c22:	bf 91       	pop	r27
     c24:	af 91       	pop	r26
     c26:	9f 91       	pop	r25
     c28:	8f 91       	pop	r24
     c2a:	7f 91       	pop	r23
     c2c:	6f 91       	pop	r22
     c2e:	5f 91       	pop	r21
     c30:	4f 91       	pop	r20
     c32:	3f 91       	pop	r19
     c34:	2f 91       	pop	r18
     c36:	0f 90       	pop	r0
     c38:	0f be       	out	0x3f, r0	; 63
     c3a:	0f 90       	pop	r0
     c3c:	1f 90       	pop	r1
     c3e:	18 95       	reti

00000c40 <__vector_14>:
     c40:	1f 92       	push	r1
     c42:	0f 92       	push	r0
     c44:	0f b6       	in	r0, 0x3f	; 63
     c46:	0f 92       	push	r0
     c48:	11 24       	eor	r1, r1
     c4a:	2f 93       	push	r18
     c4c:	3f 93       	push	r19
     c4e:	4f 93       	push	r20
     c50:	5f 93       	push	r21
     c52:	6f 93       	push	r22
     c54:	7f 93       	push	r23
     c56:	8f 93       	push	r24
     c58:	9f 93       	push	r25
     c5a:	af 93       	push	r26
     c5c:	bf 93       	push	r27
     c5e:	ef 93       	push	r30
     c60:	ff 93       	push	r31
     c62:	e0 91 26 06 	lds	r30, 0x0626	; 0x800626 <onTimer0CaptureCompareAMatch>
     c66:	f0 91 27 06 	lds	r31, 0x0627	; 0x800627 <onTimer0CaptureCompareAMatch+0x1>
     c6a:	09 95       	icall
     c6c:	ff 91       	pop	r31
     c6e:	ef 91       	pop	r30
     c70:	bf 91       	pop	r27
     c72:	af 91       	pop	r26
     c74:	9f 91       	pop	r25
     c76:	8f 91       	pop	r24
     c78:	7f 91       	pop	r23
     c7a:	6f 91       	pop	r22
     c7c:	5f 91       	pop	r21
     c7e:	4f 91       	pop	r20
     c80:	3f 91       	pop	r19
     c82:	2f 91       	pop	r18
     c84:	0f 90       	pop	r0
     c86:	0f be       	out	0x3f, r0	; 63
     c88:	0f 90       	pop	r0
     c8a:	1f 90       	pop	r1
     c8c:	18 95       	reti

00000c8e <setWaveformGenerationModeTimer0>:
     c8e:	94 b5       	in	r25, 0x24	; 36
     c90:	9c 7f       	andi	r25, 0xFC	; 252
     c92:	94 bd       	out	0x24, r25	; 36
     c94:	95 b5       	in	r25, 0x25	; 37
     c96:	97 7f       	andi	r25, 0xF7	; 247
     c98:	95 bd       	out	0x25, r25	; 37
     c9a:	94 b5       	in	r25, 0x24	; 36
     c9c:	28 2f       	mov	r18, r24
     c9e:	23 70       	andi	r18, 0x03	; 3
     ca0:	92 2b       	or	r25, r18
     ca2:	94 bd       	out	0x24, r25	; 36
     ca4:	95 b5       	in	r25, 0x25	; 37
     ca6:	84 70       	andi	r24, 0x04	; 4
     ca8:	88 0f       	add	r24, r24
     caa:	89 2b       	or	r24, r25
     cac:	85 bd       	out	0x25, r24	; 37
     cae:	08 95       	ret

00000cb0 <setPrescalerTimer0>:
     cb0:	95 b5       	in	r25, 0x25	; 37
     cb2:	98 7f       	andi	r25, 0xF8	; 248
     cb4:	95 bd       	out	0x25, r25	; 37
     cb6:	95 b5       	in	r25, 0x25	; 37
     cb8:	89 2b       	or	r24, r25
     cba:	85 bd       	out	0x25, r24	; 37
     cbc:	08 95       	ret

00000cbe <letTimer0GenerateInterruptEvery500us>:
}

void letTimer0GenerateInterruptEvery500us(void)
{
	// uses CTC mode
	OCR0A = 124;
     cbe:	8c e7       	ldi	r24, 0x7C	; 124
     cc0:	87 bd       	out	0x27, r24	; 39
	setPrescalerTimer0(PrescalerTimer0_64);
     cc2:	83 e0       	ldi	r24, 0x03	; 3
     cc4:	f5 cf       	rjmp	.-22     	; 0xcb0 <setPrescalerTimer0>
     cc6:	08 95       	ret

00000cc8 <enableTimer0CaptureCompareAInterrupt>:
}

void enableTimer0CaptureCompareAInterrupt(void)
{
	TIMSK0 |= 1<<OCIE0A;
     cc8:	ee e6       	ldi	r30, 0x6E	; 110
     cca:	f0 e0       	ldi	r31, 0x00	; 0
     ccc:	80 81       	ld	r24, Z
     cce:	82 60       	ori	r24, 0x02	; 2
     cd0:	80 83       	st	Z, r24
     cd2:	08 95       	ret

00000cd4 <defineCallbackOnTimer2CaptureCompareAMatch>:

void letTimer2GenerateInterruptEvery750us(void)
{
	// uses CTC mode
	OCR2A = 190;
	setPrescalerTimer2(PrescalerTimer2_64);
     cd4:	90 93 29 06 	sts	0x0629, r25	; 0x800629 <onTimer2CaptureCompareAMatch+0x1>
     cd8:	80 93 28 06 	sts	0x0628, r24	; 0x800628 <onTimer2CaptureCompareAMatch>
     cdc:	08 95       	ret

00000cde <__vector_9>:
     cde:	1f 92       	push	r1
     ce0:	0f 92       	push	r0
     ce2:	0f b6       	in	r0, 0x3f	; 63
     ce4:	0f 92       	push	r0
     ce6:	11 24       	eor	r1, r1
     ce8:	2f 93       	push	r18
     cea:	3f 93       	push	r19
     cec:	4f 93       	push	r20
     cee:	5f 93       	push	r21
     cf0:	6f 93       	push	r22
     cf2:	7f 93       	push	r23
     cf4:	8f 93       	push	r24
     cf6:	9f 93       	push	r25
     cf8:	af 93       	push	r26
     cfa:	bf 93       	push	r27
     cfc:	ef 93       	push	r30
     cfe:	ff 93       	push	r31
     d00:	e0 91 2a 06 	lds	r30, 0x062A	; 0x80062a <onTimer2Overflow>
     d04:	f0 91 2b 06 	lds	r31, 0x062B	; 0x80062b <onTimer2Overflow+0x1>
     d08:	09 95       	icall
     d0a:	ff 91       	pop	r31
     d0c:	ef 91       	pop	r30
     d0e:	bf 91       	pop	r27
     d10:	af 91       	pop	r26
     d12:	9f 91       	pop	r25
     d14:	8f 91       	pop	r24
     d16:	7f 91       	pop	r23
     d18:	6f 91       	pop	r22
     d1a:	5f 91       	pop	r21
     d1c:	4f 91       	pop	r20
     d1e:	3f 91       	pop	r19
     d20:	2f 91       	pop	r18
     d22:	0f 90       	pop	r0
     d24:	0f be       	out	0x3f, r0	; 63
     d26:	0f 90       	pop	r0
     d28:	1f 90       	pop	r1
     d2a:	18 95       	reti

00000d2c <__vector_7>:
     d2c:	1f 92       	push	r1
     d2e:	0f 92       	push	r0
     d30:	0f b6       	in	r0, 0x3f	; 63
     d32:	0f 92       	push	r0
     d34:	11 24       	eor	r1, r1
     d36:	2f 93       	push	r18
     d38:	3f 93       	push	r19
     d3a:	4f 93       	push	r20
     d3c:	5f 93       	push	r21
     d3e:	6f 93       	push	r22
     d40:	7f 93       	push	r23
     d42:	8f 93       	push	r24
     d44:	9f 93       	push	r25
     d46:	af 93       	push	r26
     d48:	bf 93       	push	r27
     d4a:	ef 93       	push	r30
     d4c:	ff 93       	push	r31
     d4e:	e0 91 28 06 	lds	r30, 0x0628	; 0x800628 <onTimer2CaptureCompareAMatch>
     d52:	f0 91 29 06 	lds	r31, 0x0629	; 0x800629 <onTimer2CaptureCompareAMatch+0x1>
     d56:	09 95       	icall
     d58:	ff 91       	pop	r31
     d5a:	ef 91       	pop	r30
     d5c:	bf 91       	pop	r27
     d5e:	af 91       	pop	r26
     d60:	9f 91       	pop	r25
     d62:	8f 91       	pop	r24
     d64:	7f 91       	pop	r23
     d66:	6f 91       	pop	r22
     d68:	5f 91       	pop	r21
     d6a:	4f 91       	pop	r20
     d6c:	3f 91       	pop	r19
     d6e:	2f 91       	pop	r18
     d70:	0f 90       	pop	r0
     d72:	0f be       	out	0x3f, r0	; 63
     d74:	0f 90       	pop	r0
     d76:	1f 90       	pop	r1
     d78:	18 95       	reti

00000d7a <setWaveformGenerationModeTimer2>:
     d7a:	a0 eb       	ldi	r26, 0xB0	; 176
     d7c:	b0 e0       	ldi	r27, 0x00	; 0
     d7e:	9c 91       	ld	r25, X
     d80:	9c 7f       	andi	r25, 0xFC	; 252
     d82:	9c 93       	st	X, r25
     d84:	e1 eb       	ldi	r30, 0xB1	; 177
     d86:	f0 e0       	ldi	r31, 0x00	; 0
     d88:	90 81       	ld	r25, Z
     d8a:	97 7f       	andi	r25, 0xF7	; 247
     d8c:	90 83       	st	Z, r25
     d8e:	9c 91       	ld	r25, X
     d90:	28 2f       	mov	r18, r24
     d92:	23 70       	andi	r18, 0x03	; 3
     d94:	92 2b       	or	r25, r18
     d96:	9c 93       	st	X, r25
     d98:	90 81       	ld	r25, Z
     d9a:	84 70       	andi	r24, 0x04	; 4
     d9c:	88 0f       	add	r24, r24
     d9e:	89 2b       	or	r24, r25
     da0:	80 83       	st	Z, r24
     da2:	08 95       	ret

00000da4 <setPrescalerTimer2>:
     da4:	e1 eb       	ldi	r30, 0xB1	; 177
     da6:	f0 e0       	ldi	r31, 0x00	; 0
     da8:	90 81       	ld	r25, Z
     daa:	98 7f       	andi	r25, 0xF8	; 248
     dac:	90 83       	st	Z, r25
     dae:	90 81       	ld	r25, Z
     db0:	89 2b       	or	r24, r25
     db2:	80 83       	st	Z, r24
     db4:	08 95       	ret

00000db6 <stopTimer2>:
     db6:	80 e0       	ldi	r24, 0x00	; 0
     db8:	f5 df       	rcall	.-22     	; 0xda4 <setPrescalerTimer2>
     dba:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__DATA_REGION_ORIGIN__+0x52>
     dbe:	08 95       	ret

00000dc0 <letTimer2GenerateInterruptEvery500us>:
     dc0:	8c e7       	ldi	r24, 0x7C	; 124
     dc2:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
     dc6:	84 e0       	ldi	r24, 0x04	; 4
     dc8:	ed cf       	rjmp	.-38     	; 0xda4 <setPrescalerTimer2>
     dca:	08 95       	ret

00000dcc <letTimer2GenerateInterruptEveryRoughly60us>:
     dcc:	87 e0       	ldi	r24, 0x07	; 7
     dce:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
     dd2:	85 e0       	ldi	r24, 0x05	; 5
     dd4:	e7 cf       	rjmp	.-50     	; 0xda4 <setPrescalerTimer2>
     dd6:	08 95       	ret

00000dd8 <enableTimer2CaptureCompareAInterrupt>:
}

void enableTimer2CaptureCompareAInterrupt(void)
{
	TIMSK2 |= 1<<OCIE2A;
     dd8:	e0 e7       	ldi	r30, 0x70	; 112
     dda:	f0 e0       	ldi	r31, 0x00	; 0
     ddc:	80 81       	ld	r24, Z
     dde:	82 60       	ori	r24, 0x02	; 2
     de0:	80 83       	st	Z, r24
     de2:	08 95       	ret

00000de4 <setBaudrate>:
}

void USART0_SendChar(IN_PAR const char chr)
{
	writeToBuffer(&txBuffer, chr);
	USART0_enableDataRegisterEmptyInterrupt();
     de4:	90 e0       	ldi	r25, 0x00	; 0
     de6:	fc 01       	movw	r30, r24
     de8:	31 97       	sbiw	r30, 0x01	; 1
     dea:	ea 30       	cpi	r30, 0x0A	; 10
     dec:	f1 05       	cpc	r31, r1
     dee:	08 f0       	brcs	.+2      	; 0xdf2 <setBaudrate+0xe>
     df0:	3f c0       	rjmp	.+126    	; 0xe70 <setBaudrate+0x8c>
     df2:	ec 5c       	subi	r30, 0xCC	; 204
     df4:	ff 4f       	sbci	r31, 0xFF	; 255
     df6:	aa c0       	rjmp	.+340    	; 0xf4c <__tablejump2__>
     df8:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
     dfc:	80 ed       	ldi	r24, 0xD0	; 208
     dfe:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
     e02:	08 95       	ret
     e04:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
     e08:	8a e8       	ldi	r24, 0x8A	; 138
     e0a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
     e0e:	08 95       	ret
     e10:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
     e14:	88 e6       	ldi	r24, 0x68	; 104
     e16:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
     e1a:	08 95       	ret
     e1c:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
     e20:	85 e4       	ldi	r24, 0x45	; 69
     e22:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
     e26:	08 95       	ret
     e28:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
     e2c:	84 e3       	ldi	r24, 0x34	; 52
     e2e:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
     e32:	08 95       	ret
     e34:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
     e38:	83 e2       	ldi	r24, 0x23	; 35
     e3a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
     e3e:	08 95       	ret
     e40:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
     e44:	82 e2       	ldi	r24, 0x22	; 34
     e46:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
     e4a:	08 95       	ret
     e4c:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
     e50:	81 e1       	ldi	r24, 0x11	; 17
     e52:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
     e56:	08 95       	ret
     e58:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
     e5c:	8f e0       	ldi	r24, 0x0F	; 15
     e5e:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
     e62:	08 95       	ret
     e64:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
     e68:	87 e0       	ldi	r24, 0x07	; 7
     e6a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
     e6e:	08 95       	ret
     e70:	81 e0       	ldi	r24, 0x01	; 1
     e72:	b8 cf       	rjmp	.-144    	; 0xde4 <setBaudrate>
     e74:	08 95       	ret

00000e76 <USART0_init>:
     e76:	b6 df       	rcall	.-148    	; 0xde4 <setBaudrate>
     e78:	e0 ec       	ldi	r30, 0xC0	; 192
     e7a:	f0 e0       	ldi	r31, 0x00	; 0
     e7c:	80 81       	ld	r24, Z
     e7e:	82 60       	ori	r24, 0x02	; 2
     e80:	80 83       	st	Z, r24
     e82:	e1 ec       	ldi	r30, 0xC1	; 193
     e84:	f0 e0       	ldi	r31, 0x00	; 0
     e86:	80 81       	ld	r24, Z
     e88:	88 60       	ori	r24, 0x08	; 8
     e8a:	80 83       	st	Z, r24
     e8c:	e2 ec       	ldi	r30, 0xC2	; 194
     e8e:	f0 e0       	ldi	r31, 0x00	; 0
     e90:	80 81       	ld	r24, Z
     e92:	86 60       	ori	r24, 0x06	; 6
     e94:	80 83       	st	Z, r24
     e96:	08 95       	ret

00000e98 <USART0_enableDataRegisterEmptyInterrupt>:
     e98:	e1 ec       	ldi	r30, 0xC1	; 193
     e9a:	f0 e0       	ldi	r31, 0x00	; 0
     e9c:	80 81       	ld	r24, Z
     e9e:	80 62       	ori	r24, 0x20	; 32
     ea0:	80 83       	st	Z, r24
     ea2:	08 95       	ret

00000ea4 <USART0_disableDataRegisterEmptyInterrupt>:
     ea4:	e1 ec       	ldi	r30, 0xC1	; 193
     ea6:	f0 e0       	ldi	r31, 0x00	; 0
     ea8:	80 81       	ld	r24, Z
     eaa:	8f 7d       	andi	r24, 0xDF	; 223
     eac:	80 83       	st	Z, r24
     eae:	08 95       	ret

00000eb0 <USART0_SendString>:
     eb0:	0f 93       	push	r16
     eb2:	1f 93       	push	r17
     eb4:	cf 93       	push	r28
     eb6:	df 93       	push	r29
     eb8:	66 23       	and	r22, r22
     eba:	79 f0       	breq	.+30     	; 0xeda <USART0_SendString+0x2a>
     ebc:	ec 01       	movw	r28, r24
     ebe:	61 50       	subi	r22, 0x01	; 1
     ec0:	06 2f       	mov	r16, r22
     ec2:	10 e0       	ldi	r17, 0x00	; 0
     ec4:	0f 5f       	subi	r16, 0xFF	; 255
     ec6:	1f 4f       	sbci	r17, 0xFF	; 255
     ec8:	08 0f       	add	r16, r24
     eca:	19 1f       	adc	r17, r25
     ecc:	69 91       	ld	r22, Y+
     ece:	8c ee       	ldi	r24, 0xEC	; 236
     ed0:	91 e0       	ldi	r25, 0x01	; 1
     ed2:	86 da       	rcall	.-2804   	; 0x3e0 <writeToBuffer>
     ed4:	c0 17       	cp	r28, r16
     ed6:	d1 07       	cpc	r29, r17
     ed8:	c9 f7       	brne	.-14     	; 0xecc <USART0_SendString+0x1c>
     eda:	de df       	rcall	.-68     	; 0xe98 <USART0_enableDataRegisterEmptyInterrupt>
     edc:	df 91       	pop	r29
     ede:	cf 91       	pop	r28
     ee0:	1f 91       	pop	r17
     ee2:	0f 91       	pop	r16
     ee4:	08 95       	ret

00000ee6 <__vector_19>:
}

ISR(USART_UDRE_vect)
{
     ee6:	1f 92       	push	r1
     ee8:	0f 92       	push	r0
     eea:	0f b6       	in	r0, 0x3f	; 63
     eec:	0f 92       	push	r0
     eee:	11 24       	eor	r1, r1
     ef0:	2f 93       	push	r18
     ef2:	3f 93       	push	r19
     ef4:	4f 93       	push	r20
     ef6:	5f 93       	push	r21
     ef8:	6f 93       	push	r22
     efa:	7f 93       	push	r23
     efc:	8f 93       	push	r24
     efe:	9f 93       	push	r25
     f00:	af 93       	push	r26
     f02:	bf 93       	push	r27
     f04:	ef 93       	push	r30
     f06:	ff 93       	push	r31
	// on output data register empty
	UCSR0A |= (1<<UDRE0); //When the Data Register Empty Interrupt Enable (UDRIEn) bit in UCSRnB is written to one, the USART Data Register Empty Interrupt will be executed as long as UDREn is set (provided that global interrupts are enabled). UDREn is cleared by writing UDRn. (see Datasheet ATmega2560 p.208f/435)
     f08:	e0 ec       	ldi	r30, 0xC0	; 192
     f0a:	f0 e0       	ldi	r31, 0x00	; 0
     f0c:	80 81       	ld	r24, Z
     f0e:	80 62       	ori	r24, 0x20	; 32
     f10:	80 83       	st	Z, r24
	if(bytesAvailableInBuffer(&txBuffer))
     f12:	8c ee       	ldi	r24, 0xEC	; 236
     f14:	91 e0       	ldi	r25, 0x01	; 1
     f16:	7c da       	rcall	.-2824   	; 0x410 <bytesAvailableInBuffer>
     f18:	89 2b       	or	r24, r25
     f1a:	31 f0       	breq	.+12     	; 0xf28 <__vector_19+0x42>
		UDR0 = readFromBuffer(&txBuffer);
     f1c:	8c ee       	ldi	r24, 0xEC	; 236
     f1e:	91 e0       	ldi	r25, 0x01	; 1
     f20:	6b da       	rcall	.-2858   	; 0x3f8 <readFromBuffer>
     f22:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
	else
	{
		USART0_disableDataRegisterEmptyInterrupt();
     f26:	01 c0       	rjmp	.+2      	; 0xf2a <__vector_19+0x44>
     f28:	bd df       	rcall	.-134    	; 0xea4 <USART0_disableDataRegisterEmptyInterrupt>
	}
     f2a:	ff 91       	pop	r31
     f2c:	ef 91       	pop	r30
     f2e:	bf 91       	pop	r27
     f30:	af 91       	pop	r26
     f32:	9f 91       	pop	r25
     f34:	8f 91       	pop	r24
     f36:	7f 91       	pop	r23
     f38:	6f 91       	pop	r22
     f3a:	5f 91       	pop	r21
     f3c:	4f 91       	pop	r20
     f3e:	3f 91       	pop	r19
     f40:	2f 91       	pop	r18
     f42:	0f 90       	pop	r0
     f44:	0f be       	out	0x3f, r0	; 63
     f46:	0f 90       	pop	r0
     f48:	1f 90       	pop	r1
     f4a:	18 95       	reti

00000f4c <__tablejump2__>:
     f4c:	ee 0f       	add	r30, r30
     f4e:	ff 1f       	adc	r31, r31
     f50:	05 90       	lpm	r0, Z+
     f52:	f4 91       	lpm	r31, Z
     f54:	e0 2d       	mov	r30, r0
     f56:	09 94       	ijmp

00000f58 <malloc>:
     f58:	0f 93       	push	r16
     f5a:	1f 93       	push	r17
     f5c:	cf 93       	push	r28
     f5e:	df 93       	push	r29
     f60:	82 30       	cpi	r24, 0x02	; 2
     f62:	91 05       	cpc	r25, r1
     f64:	10 f4       	brcc	.+4      	; 0xf6a <malloc+0x12>
     f66:	82 e0       	ldi	r24, 0x02	; 2
     f68:	90 e0       	ldi	r25, 0x00	; 0
     f6a:	e0 91 2e 06 	lds	r30, 0x062E	; 0x80062e <__flp>
     f6e:	f0 91 2f 06 	lds	r31, 0x062F	; 0x80062f <__flp+0x1>
     f72:	20 e0       	ldi	r18, 0x00	; 0
     f74:	30 e0       	ldi	r19, 0x00	; 0
     f76:	a0 e0       	ldi	r26, 0x00	; 0
     f78:	b0 e0       	ldi	r27, 0x00	; 0
     f7a:	30 97       	sbiw	r30, 0x00	; 0
     f7c:	19 f1       	breq	.+70     	; 0xfc4 <malloc+0x6c>
     f7e:	40 81       	ld	r20, Z
     f80:	51 81       	ldd	r21, Z+1	; 0x01
     f82:	02 81       	ldd	r16, Z+2	; 0x02
     f84:	13 81       	ldd	r17, Z+3	; 0x03
     f86:	48 17       	cp	r20, r24
     f88:	59 07       	cpc	r21, r25
     f8a:	c8 f0       	brcs	.+50     	; 0xfbe <malloc+0x66>
     f8c:	84 17       	cp	r24, r20
     f8e:	95 07       	cpc	r25, r21
     f90:	69 f4       	brne	.+26     	; 0xfac <malloc+0x54>
     f92:	10 97       	sbiw	r26, 0x00	; 0
     f94:	31 f0       	breq	.+12     	; 0xfa2 <malloc+0x4a>
     f96:	12 96       	adiw	r26, 0x02	; 2
     f98:	0c 93       	st	X, r16
     f9a:	12 97       	sbiw	r26, 0x02	; 2
     f9c:	13 96       	adiw	r26, 0x03	; 3
     f9e:	1c 93       	st	X, r17
     fa0:	27 c0       	rjmp	.+78     	; 0xff0 <malloc+0x98>
     fa2:	00 93 2e 06 	sts	0x062E, r16	; 0x80062e <__flp>
     fa6:	10 93 2f 06 	sts	0x062F, r17	; 0x80062f <__flp+0x1>
     faa:	22 c0       	rjmp	.+68     	; 0xff0 <malloc+0x98>
     fac:	21 15       	cp	r18, r1
     fae:	31 05       	cpc	r19, r1
     fb0:	19 f0       	breq	.+6      	; 0xfb8 <malloc+0x60>
     fb2:	42 17       	cp	r20, r18
     fb4:	53 07       	cpc	r21, r19
     fb6:	18 f4       	brcc	.+6      	; 0xfbe <malloc+0x66>
     fb8:	9a 01       	movw	r18, r20
     fba:	bd 01       	movw	r22, r26
     fbc:	ef 01       	movw	r28, r30
     fbe:	df 01       	movw	r26, r30
     fc0:	f8 01       	movw	r30, r16
     fc2:	db cf       	rjmp	.-74     	; 0xf7a <malloc+0x22>
     fc4:	21 15       	cp	r18, r1
     fc6:	31 05       	cpc	r19, r1
     fc8:	f9 f0       	breq	.+62     	; 0x1008 <malloc+0xb0>
     fca:	28 1b       	sub	r18, r24
     fcc:	39 0b       	sbc	r19, r25
     fce:	24 30       	cpi	r18, 0x04	; 4
     fd0:	31 05       	cpc	r19, r1
     fd2:	80 f4       	brcc	.+32     	; 0xff4 <malloc+0x9c>
     fd4:	8a 81       	ldd	r24, Y+2	; 0x02
     fd6:	9b 81       	ldd	r25, Y+3	; 0x03
     fd8:	61 15       	cp	r22, r1
     fda:	71 05       	cpc	r23, r1
     fdc:	21 f0       	breq	.+8      	; 0xfe6 <malloc+0x8e>
     fde:	fb 01       	movw	r30, r22
     fe0:	93 83       	std	Z+3, r25	; 0x03
     fe2:	82 83       	std	Z+2, r24	; 0x02
     fe4:	04 c0       	rjmp	.+8      	; 0xfee <malloc+0x96>
     fe6:	90 93 2f 06 	sts	0x062F, r25	; 0x80062f <__flp+0x1>
     fea:	80 93 2e 06 	sts	0x062E, r24	; 0x80062e <__flp>
     fee:	fe 01       	movw	r30, r28
     ff0:	32 96       	adiw	r30, 0x02	; 2
     ff2:	44 c0       	rjmp	.+136    	; 0x107c <malloc+0x124>
     ff4:	fe 01       	movw	r30, r28
     ff6:	e2 0f       	add	r30, r18
     ff8:	f3 1f       	adc	r31, r19
     ffa:	81 93       	st	Z+, r24
     ffc:	91 93       	st	Z+, r25
     ffe:	22 50       	subi	r18, 0x02	; 2
    1000:	31 09       	sbc	r19, r1
    1002:	39 83       	std	Y+1, r19	; 0x01
    1004:	28 83       	st	Y, r18
    1006:	3a c0       	rjmp	.+116    	; 0x107c <malloc+0x124>
    1008:	20 91 2c 06 	lds	r18, 0x062C	; 0x80062c <__brkval>
    100c:	30 91 2d 06 	lds	r19, 0x062D	; 0x80062d <__brkval+0x1>
    1010:	23 2b       	or	r18, r19
    1012:	41 f4       	brne	.+16     	; 0x1024 <malloc+0xcc>
    1014:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    1018:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    101c:	30 93 2d 06 	sts	0x062D, r19	; 0x80062d <__brkval+0x1>
    1020:	20 93 2c 06 	sts	0x062C, r18	; 0x80062c <__brkval>
    1024:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    1028:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    102c:	21 15       	cp	r18, r1
    102e:	31 05       	cpc	r19, r1
    1030:	41 f4       	brne	.+16     	; 0x1042 <malloc+0xea>
    1032:	2d b7       	in	r18, 0x3d	; 61
    1034:	3e b7       	in	r19, 0x3e	; 62
    1036:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    103a:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    103e:	24 1b       	sub	r18, r20
    1040:	35 0b       	sbc	r19, r21
    1042:	e0 91 2c 06 	lds	r30, 0x062C	; 0x80062c <__brkval>
    1046:	f0 91 2d 06 	lds	r31, 0x062D	; 0x80062d <__brkval+0x1>
    104a:	e2 17       	cp	r30, r18
    104c:	f3 07       	cpc	r31, r19
    104e:	a0 f4       	brcc	.+40     	; 0x1078 <malloc+0x120>
    1050:	2e 1b       	sub	r18, r30
    1052:	3f 0b       	sbc	r19, r31
    1054:	28 17       	cp	r18, r24
    1056:	39 07       	cpc	r19, r25
    1058:	78 f0       	brcs	.+30     	; 0x1078 <malloc+0x120>
    105a:	ac 01       	movw	r20, r24
    105c:	4e 5f       	subi	r20, 0xFE	; 254
    105e:	5f 4f       	sbci	r21, 0xFF	; 255
    1060:	24 17       	cp	r18, r20
    1062:	35 07       	cpc	r19, r21
    1064:	48 f0       	brcs	.+18     	; 0x1078 <malloc+0x120>
    1066:	4e 0f       	add	r20, r30
    1068:	5f 1f       	adc	r21, r31
    106a:	50 93 2d 06 	sts	0x062D, r21	; 0x80062d <__brkval+0x1>
    106e:	40 93 2c 06 	sts	0x062C, r20	; 0x80062c <__brkval>
    1072:	81 93       	st	Z+, r24
    1074:	91 93       	st	Z+, r25
    1076:	02 c0       	rjmp	.+4      	; 0x107c <malloc+0x124>
    1078:	e0 e0       	ldi	r30, 0x00	; 0
    107a:	f0 e0       	ldi	r31, 0x00	; 0
    107c:	cf 01       	movw	r24, r30
    107e:	df 91       	pop	r29
    1080:	cf 91       	pop	r28
    1082:	1f 91       	pop	r17
    1084:	0f 91       	pop	r16
    1086:	08 95       	ret

00001088 <free>:
    1088:	cf 93       	push	r28
    108a:	df 93       	push	r29
    108c:	00 97       	sbiw	r24, 0x00	; 0
    108e:	09 f4       	brne	.+2      	; 0x1092 <free+0xa>
    1090:	81 c0       	rjmp	.+258    	; 0x1194 <free+0x10c>
    1092:	fc 01       	movw	r30, r24
    1094:	32 97       	sbiw	r30, 0x02	; 2
    1096:	13 82       	std	Z+3, r1	; 0x03
    1098:	12 82       	std	Z+2, r1	; 0x02
    109a:	a0 91 2e 06 	lds	r26, 0x062E	; 0x80062e <__flp>
    109e:	b0 91 2f 06 	lds	r27, 0x062F	; 0x80062f <__flp+0x1>
    10a2:	10 97       	sbiw	r26, 0x00	; 0
    10a4:	81 f4       	brne	.+32     	; 0x10c6 <free+0x3e>
    10a6:	20 81       	ld	r18, Z
    10a8:	31 81       	ldd	r19, Z+1	; 0x01
    10aa:	82 0f       	add	r24, r18
    10ac:	93 1f       	adc	r25, r19
    10ae:	20 91 2c 06 	lds	r18, 0x062C	; 0x80062c <__brkval>
    10b2:	30 91 2d 06 	lds	r19, 0x062D	; 0x80062d <__brkval+0x1>
    10b6:	28 17       	cp	r18, r24
    10b8:	39 07       	cpc	r19, r25
    10ba:	51 f5       	brne	.+84     	; 0x1110 <free+0x88>
    10bc:	f0 93 2d 06 	sts	0x062D, r31	; 0x80062d <__brkval+0x1>
    10c0:	e0 93 2c 06 	sts	0x062C, r30	; 0x80062c <__brkval>
    10c4:	67 c0       	rjmp	.+206    	; 0x1194 <free+0x10c>
    10c6:	ed 01       	movw	r28, r26
    10c8:	20 e0       	ldi	r18, 0x00	; 0
    10ca:	30 e0       	ldi	r19, 0x00	; 0
    10cc:	ce 17       	cp	r28, r30
    10ce:	df 07       	cpc	r29, r31
    10d0:	40 f4       	brcc	.+16     	; 0x10e2 <free+0x5a>
    10d2:	4a 81       	ldd	r20, Y+2	; 0x02
    10d4:	5b 81       	ldd	r21, Y+3	; 0x03
    10d6:	9e 01       	movw	r18, r28
    10d8:	41 15       	cp	r20, r1
    10da:	51 05       	cpc	r21, r1
    10dc:	f1 f0       	breq	.+60     	; 0x111a <free+0x92>
    10de:	ea 01       	movw	r28, r20
    10e0:	f5 cf       	rjmp	.-22     	; 0x10cc <free+0x44>
    10e2:	d3 83       	std	Z+3, r29	; 0x03
    10e4:	c2 83       	std	Z+2, r28	; 0x02
    10e6:	40 81       	ld	r20, Z
    10e8:	51 81       	ldd	r21, Z+1	; 0x01
    10ea:	84 0f       	add	r24, r20
    10ec:	95 1f       	adc	r25, r21
    10ee:	c8 17       	cp	r28, r24
    10f0:	d9 07       	cpc	r29, r25
    10f2:	59 f4       	brne	.+22     	; 0x110a <free+0x82>
    10f4:	88 81       	ld	r24, Y
    10f6:	99 81       	ldd	r25, Y+1	; 0x01
    10f8:	84 0f       	add	r24, r20
    10fa:	95 1f       	adc	r25, r21
    10fc:	02 96       	adiw	r24, 0x02	; 2
    10fe:	91 83       	std	Z+1, r25	; 0x01
    1100:	80 83       	st	Z, r24
    1102:	8a 81       	ldd	r24, Y+2	; 0x02
    1104:	9b 81       	ldd	r25, Y+3	; 0x03
    1106:	93 83       	std	Z+3, r25	; 0x03
    1108:	82 83       	std	Z+2, r24	; 0x02
    110a:	21 15       	cp	r18, r1
    110c:	31 05       	cpc	r19, r1
    110e:	29 f4       	brne	.+10     	; 0x111a <free+0x92>
    1110:	f0 93 2f 06 	sts	0x062F, r31	; 0x80062f <__flp+0x1>
    1114:	e0 93 2e 06 	sts	0x062E, r30	; 0x80062e <__flp>
    1118:	3d c0       	rjmp	.+122    	; 0x1194 <free+0x10c>
    111a:	e9 01       	movw	r28, r18
    111c:	fb 83       	std	Y+3, r31	; 0x03
    111e:	ea 83       	std	Y+2, r30	; 0x02
    1120:	49 91       	ld	r20, Y+
    1122:	59 91       	ld	r21, Y+
    1124:	c4 0f       	add	r28, r20
    1126:	d5 1f       	adc	r29, r21
    1128:	ec 17       	cp	r30, r28
    112a:	fd 07       	cpc	r31, r29
    112c:	61 f4       	brne	.+24     	; 0x1146 <free+0xbe>
    112e:	80 81       	ld	r24, Z
    1130:	91 81       	ldd	r25, Z+1	; 0x01
    1132:	84 0f       	add	r24, r20
    1134:	95 1f       	adc	r25, r21
    1136:	02 96       	adiw	r24, 0x02	; 2
    1138:	e9 01       	movw	r28, r18
    113a:	99 83       	std	Y+1, r25	; 0x01
    113c:	88 83       	st	Y, r24
    113e:	82 81       	ldd	r24, Z+2	; 0x02
    1140:	93 81       	ldd	r25, Z+3	; 0x03
    1142:	9b 83       	std	Y+3, r25	; 0x03
    1144:	8a 83       	std	Y+2, r24	; 0x02
    1146:	e0 e0       	ldi	r30, 0x00	; 0
    1148:	f0 e0       	ldi	r31, 0x00	; 0
    114a:	12 96       	adiw	r26, 0x02	; 2
    114c:	8d 91       	ld	r24, X+
    114e:	9c 91       	ld	r25, X
    1150:	13 97       	sbiw	r26, 0x03	; 3
    1152:	00 97       	sbiw	r24, 0x00	; 0
    1154:	19 f0       	breq	.+6      	; 0x115c <free+0xd4>
    1156:	fd 01       	movw	r30, r26
    1158:	dc 01       	movw	r26, r24
    115a:	f7 cf       	rjmp	.-18     	; 0x114a <free+0xc2>
    115c:	8d 91       	ld	r24, X+
    115e:	9c 91       	ld	r25, X
    1160:	11 97       	sbiw	r26, 0x01	; 1
    1162:	9d 01       	movw	r18, r26
    1164:	2e 5f       	subi	r18, 0xFE	; 254
    1166:	3f 4f       	sbci	r19, 0xFF	; 255
    1168:	82 0f       	add	r24, r18
    116a:	93 1f       	adc	r25, r19
    116c:	20 91 2c 06 	lds	r18, 0x062C	; 0x80062c <__brkval>
    1170:	30 91 2d 06 	lds	r19, 0x062D	; 0x80062d <__brkval+0x1>
    1174:	28 17       	cp	r18, r24
    1176:	39 07       	cpc	r19, r25
    1178:	69 f4       	brne	.+26     	; 0x1194 <free+0x10c>
    117a:	30 97       	sbiw	r30, 0x00	; 0
    117c:	29 f4       	brne	.+10     	; 0x1188 <free+0x100>
    117e:	10 92 2f 06 	sts	0x062F, r1	; 0x80062f <__flp+0x1>
    1182:	10 92 2e 06 	sts	0x062E, r1	; 0x80062e <__flp>
    1186:	02 c0       	rjmp	.+4      	; 0x118c <free+0x104>
    1188:	13 82       	std	Z+3, r1	; 0x03
    118a:	12 82       	std	Z+2, r1	; 0x02
    118c:	b0 93 2d 06 	sts	0x062D, r27	; 0x80062d <__brkval+0x1>
    1190:	a0 93 2c 06 	sts	0x062C, r26	; 0x80062c <__brkval>
    1194:	df 91       	pop	r29
    1196:	cf 91       	pop	r28
    1198:	08 95       	ret

0000119a <sprintf>:
    119a:	ae e0       	ldi	r26, 0x0E	; 14
    119c:	b0 e0       	ldi	r27, 0x00	; 0
    119e:	e2 ed       	ldi	r30, 0xD2	; 210
    11a0:	f8 e0       	ldi	r31, 0x08	; 8
    11a2:	aa c2       	rjmp	.+1364   	; 0x16f8 <__prologue_saves__+0x1c>
    11a4:	0d 89       	ldd	r16, Y+21	; 0x15
    11a6:	1e 89       	ldd	r17, Y+22	; 0x16
    11a8:	86 e0       	ldi	r24, 0x06	; 6
    11aa:	8c 83       	std	Y+4, r24	; 0x04
    11ac:	1a 83       	std	Y+2, r17	; 0x02
    11ae:	09 83       	std	Y+1, r16	; 0x01
    11b0:	8f ef       	ldi	r24, 0xFF	; 255
    11b2:	9f e7       	ldi	r25, 0x7F	; 127
    11b4:	9e 83       	std	Y+6, r25	; 0x06
    11b6:	8d 83       	std	Y+5, r24	; 0x05
    11b8:	ae 01       	movw	r20, r28
    11ba:	47 5e       	subi	r20, 0xE7	; 231
    11bc:	5f 4f       	sbci	r21, 0xFF	; 255
    11be:	6f 89       	ldd	r22, Y+23	; 0x17
    11c0:	78 8d       	ldd	r23, Y+24	; 0x18
    11c2:	ce 01       	movw	r24, r28
    11c4:	01 96       	adiw	r24, 0x01	; 1
    11c6:	08 d0       	rcall	.+16     	; 0x11d8 <vfprintf>
    11c8:	ef 81       	ldd	r30, Y+7	; 0x07
    11ca:	f8 85       	ldd	r31, Y+8	; 0x08
    11cc:	e0 0f       	add	r30, r16
    11ce:	f1 1f       	adc	r31, r17
    11d0:	10 82       	st	Z, r1
    11d2:	2e 96       	adiw	r28, 0x0e	; 14
    11d4:	e4 e0       	ldi	r30, 0x04	; 4
    11d6:	ac c2       	rjmp	.+1368   	; 0x1730 <__epilogue_restores__+0x1c>

000011d8 <vfprintf>:
    11d8:	ab e0       	ldi	r26, 0x0B	; 11
    11da:	b0 e0       	ldi	r27, 0x00	; 0
    11dc:	e1 ef       	ldi	r30, 0xF1	; 241
    11de:	f8 e0       	ldi	r31, 0x08	; 8
    11e0:	7d c2       	rjmp	.+1274   	; 0x16dc <__prologue_saves__>
    11e2:	6c 01       	movw	r12, r24
    11e4:	7b 01       	movw	r14, r22
    11e6:	8a 01       	movw	r16, r20
    11e8:	fc 01       	movw	r30, r24
    11ea:	17 82       	std	Z+7, r1	; 0x07
    11ec:	16 82       	std	Z+6, r1	; 0x06
    11ee:	83 81       	ldd	r24, Z+3	; 0x03
    11f0:	81 ff       	sbrs	r24, 1
    11f2:	bf c1       	rjmp	.+894    	; 0x1572 <vfprintf+0x39a>
    11f4:	ce 01       	movw	r24, r28
    11f6:	01 96       	adiw	r24, 0x01	; 1
    11f8:	3c 01       	movw	r6, r24
    11fa:	f6 01       	movw	r30, r12
    11fc:	93 81       	ldd	r25, Z+3	; 0x03
    11fe:	f7 01       	movw	r30, r14
    1200:	93 fd       	sbrc	r25, 3
    1202:	85 91       	lpm	r24, Z+
    1204:	93 ff       	sbrs	r25, 3
    1206:	81 91       	ld	r24, Z+
    1208:	7f 01       	movw	r14, r30
    120a:	88 23       	and	r24, r24
    120c:	09 f4       	brne	.+2      	; 0x1210 <vfprintf+0x38>
    120e:	ad c1       	rjmp	.+858    	; 0x156a <vfprintf+0x392>
    1210:	85 32       	cpi	r24, 0x25	; 37
    1212:	39 f4       	brne	.+14     	; 0x1222 <vfprintf+0x4a>
    1214:	93 fd       	sbrc	r25, 3
    1216:	85 91       	lpm	r24, Z+
    1218:	93 ff       	sbrs	r25, 3
    121a:	81 91       	ld	r24, Z+
    121c:	7f 01       	movw	r14, r30
    121e:	85 32       	cpi	r24, 0x25	; 37
    1220:	21 f4       	brne	.+8      	; 0x122a <vfprintf+0x52>
    1222:	b6 01       	movw	r22, r12
    1224:	90 e0       	ldi	r25, 0x00	; 0
    1226:	c0 d1       	rcall	.+896    	; 0x15a8 <fputc>
    1228:	e8 cf       	rjmp	.-48     	; 0x11fa <vfprintf+0x22>
    122a:	91 2c       	mov	r9, r1
    122c:	21 2c       	mov	r2, r1
    122e:	31 2c       	mov	r3, r1
    1230:	ff e1       	ldi	r31, 0x1F	; 31
    1232:	f3 15       	cp	r31, r3
    1234:	d8 f0       	brcs	.+54     	; 0x126c <vfprintf+0x94>
    1236:	8b 32       	cpi	r24, 0x2B	; 43
    1238:	79 f0       	breq	.+30     	; 0x1258 <vfprintf+0x80>
    123a:	38 f4       	brcc	.+14     	; 0x124a <vfprintf+0x72>
    123c:	80 32       	cpi	r24, 0x20	; 32
    123e:	79 f0       	breq	.+30     	; 0x125e <vfprintf+0x86>
    1240:	83 32       	cpi	r24, 0x23	; 35
    1242:	a1 f4       	brne	.+40     	; 0x126c <vfprintf+0x94>
    1244:	23 2d       	mov	r18, r3
    1246:	20 61       	ori	r18, 0x10	; 16
    1248:	1d c0       	rjmp	.+58     	; 0x1284 <vfprintf+0xac>
    124a:	8d 32       	cpi	r24, 0x2D	; 45
    124c:	61 f0       	breq	.+24     	; 0x1266 <vfprintf+0x8e>
    124e:	80 33       	cpi	r24, 0x30	; 48
    1250:	69 f4       	brne	.+26     	; 0x126c <vfprintf+0x94>
    1252:	23 2d       	mov	r18, r3
    1254:	21 60       	ori	r18, 0x01	; 1
    1256:	16 c0       	rjmp	.+44     	; 0x1284 <vfprintf+0xac>
    1258:	83 2d       	mov	r24, r3
    125a:	82 60       	ori	r24, 0x02	; 2
    125c:	38 2e       	mov	r3, r24
    125e:	e3 2d       	mov	r30, r3
    1260:	e4 60       	ori	r30, 0x04	; 4
    1262:	3e 2e       	mov	r3, r30
    1264:	2a c0       	rjmp	.+84     	; 0x12ba <vfprintf+0xe2>
    1266:	f3 2d       	mov	r31, r3
    1268:	f8 60       	ori	r31, 0x08	; 8
    126a:	1d c0       	rjmp	.+58     	; 0x12a6 <vfprintf+0xce>
    126c:	37 fc       	sbrc	r3, 7
    126e:	2d c0       	rjmp	.+90     	; 0x12ca <vfprintf+0xf2>
    1270:	20 ed       	ldi	r18, 0xD0	; 208
    1272:	28 0f       	add	r18, r24
    1274:	2a 30       	cpi	r18, 0x0A	; 10
    1276:	40 f0       	brcs	.+16     	; 0x1288 <vfprintf+0xb0>
    1278:	8e 32       	cpi	r24, 0x2E	; 46
    127a:	b9 f4       	brne	.+46     	; 0x12aa <vfprintf+0xd2>
    127c:	36 fc       	sbrc	r3, 6
    127e:	75 c1       	rjmp	.+746    	; 0x156a <vfprintf+0x392>
    1280:	23 2d       	mov	r18, r3
    1282:	20 64       	ori	r18, 0x40	; 64
    1284:	32 2e       	mov	r3, r18
    1286:	19 c0       	rjmp	.+50     	; 0x12ba <vfprintf+0xe2>
    1288:	36 fe       	sbrs	r3, 6
    128a:	06 c0       	rjmp	.+12     	; 0x1298 <vfprintf+0xc0>
    128c:	8a e0       	ldi	r24, 0x0A	; 10
    128e:	98 9e       	mul	r9, r24
    1290:	20 0d       	add	r18, r0
    1292:	11 24       	eor	r1, r1
    1294:	92 2e       	mov	r9, r18
    1296:	11 c0       	rjmp	.+34     	; 0x12ba <vfprintf+0xe2>
    1298:	ea e0       	ldi	r30, 0x0A	; 10
    129a:	2e 9e       	mul	r2, r30
    129c:	20 0d       	add	r18, r0
    129e:	11 24       	eor	r1, r1
    12a0:	22 2e       	mov	r2, r18
    12a2:	f3 2d       	mov	r31, r3
    12a4:	f0 62       	ori	r31, 0x20	; 32
    12a6:	3f 2e       	mov	r3, r31
    12a8:	08 c0       	rjmp	.+16     	; 0x12ba <vfprintf+0xe2>
    12aa:	8c 36       	cpi	r24, 0x6C	; 108
    12ac:	21 f4       	brne	.+8      	; 0x12b6 <vfprintf+0xde>
    12ae:	83 2d       	mov	r24, r3
    12b0:	80 68       	ori	r24, 0x80	; 128
    12b2:	38 2e       	mov	r3, r24
    12b4:	02 c0       	rjmp	.+4      	; 0x12ba <vfprintf+0xe2>
    12b6:	88 36       	cpi	r24, 0x68	; 104
    12b8:	41 f4       	brne	.+16     	; 0x12ca <vfprintf+0xf2>
    12ba:	f7 01       	movw	r30, r14
    12bc:	93 fd       	sbrc	r25, 3
    12be:	85 91       	lpm	r24, Z+
    12c0:	93 ff       	sbrs	r25, 3
    12c2:	81 91       	ld	r24, Z+
    12c4:	7f 01       	movw	r14, r30
    12c6:	81 11       	cpse	r24, r1
    12c8:	b3 cf       	rjmp	.-154    	; 0x1230 <vfprintf+0x58>
    12ca:	98 2f       	mov	r25, r24
    12cc:	9f 7d       	andi	r25, 0xDF	; 223
    12ce:	95 54       	subi	r25, 0x45	; 69
    12d0:	93 30       	cpi	r25, 0x03	; 3
    12d2:	28 f4       	brcc	.+10     	; 0x12de <vfprintf+0x106>
    12d4:	0c 5f       	subi	r16, 0xFC	; 252
    12d6:	1f 4f       	sbci	r17, 0xFF	; 255
    12d8:	9f e3       	ldi	r25, 0x3F	; 63
    12da:	99 83       	std	Y+1, r25	; 0x01
    12dc:	0d c0       	rjmp	.+26     	; 0x12f8 <vfprintf+0x120>
    12de:	83 36       	cpi	r24, 0x63	; 99
    12e0:	31 f0       	breq	.+12     	; 0x12ee <vfprintf+0x116>
    12e2:	83 37       	cpi	r24, 0x73	; 115
    12e4:	71 f0       	breq	.+28     	; 0x1302 <vfprintf+0x12a>
    12e6:	83 35       	cpi	r24, 0x53	; 83
    12e8:	09 f0       	breq	.+2      	; 0x12ec <vfprintf+0x114>
    12ea:	55 c0       	rjmp	.+170    	; 0x1396 <vfprintf+0x1be>
    12ec:	20 c0       	rjmp	.+64     	; 0x132e <vfprintf+0x156>
    12ee:	f8 01       	movw	r30, r16
    12f0:	80 81       	ld	r24, Z
    12f2:	89 83       	std	Y+1, r24	; 0x01
    12f4:	0e 5f       	subi	r16, 0xFE	; 254
    12f6:	1f 4f       	sbci	r17, 0xFF	; 255
    12f8:	88 24       	eor	r8, r8
    12fa:	83 94       	inc	r8
    12fc:	91 2c       	mov	r9, r1
    12fe:	53 01       	movw	r10, r6
    1300:	12 c0       	rjmp	.+36     	; 0x1326 <vfprintf+0x14e>
    1302:	28 01       	movw	r4, r16
    1304:	f2 e0       	ldi	r31, 0x02	; 2
    1306:	4f 0e       	add	r4, r31
    1308:	51 1c       	adc	r5, r1
    130a:	f8 01       	movw	r30, r16
    130c:	a0 80       	ld	r10, Z
    130e:	b1 80       	ldd	r11, Z+1	; 0x01
    1310:	36 fe       	sbrs	r3, 6
    1312:	03 c0       	rjmp	.+6      	; 0x131a <vfprintf+0x142>
    1314:	69 2d       	mov	r22, r9
    1316:	70 e0       	ldi	r23, 0x00	; 0
    1318:	02 c0       	rjmp	.+4      	; 0x131e <vfprintf+0x146>
    131a:	6f ef       	ldi	r22, 0xFF	; 255
    131c:	7f ef       	ldi	r23, 0xFF	; 255
    131e:	c5 01       	movw	r24, r10
    1320:	38 d1       	rcall	.+624    	; 0x1592 <strnlen>
    1322:	4c 01       	movw	r8, r24
    1324:	82 01       	movw	r16, r4
    1326:	f3 2d       	mov	r31, r3
    1328:	ff 77       	andi	r31, 0x7F	; 127
    132a:	3f 2e       	mov	r3, r31
    132c:	15 c0       	rjmp	.+42     	; 0x1358 <vfprintf+0x180>
    132e:	28 01       	movw	r4, r16
    1330:	22 e0       	ldi	r18, 0x02	; 2
    1332:	42 0e       	add	r4, r18
    1334:	51 1c       	adc	r5, r1
    1336:	f8 01       	movw	r30, r16
    1338:	a0 80       	ld	r10, Z
    133a:	b1 80       	ldd	r11, Z+1	; 0x01
    133c:	36 fe       	sbrs	r3, 6
    133e:	03 c0       	rjmp	.+6      	; 0x1346 <vfprintf+0x16e>
    1340:	69 2d       	mov	r22, r9
    1342:	70 e0       	ldi	r23, 0x00	; 0
    1344:	02 c0       	rjmp	.+4      	; 0x134a <vfprintf+0x172>
    1346:	6f ef       	ldi	r22, 0xFF	; 255
    1348:	7f ef       	ldi	r23, 0xFF	; 255
    134a:	c5 01       	movw	r24, r10
    134c:	17 d1       	rcall	.+558    	; 0x157c <strnlen_P>
    134e:	4c 01       	movw	r8, r24
    1350:	f3 2d       	mov	r31, r3
    1352:	f0 68       	ori	r31, 0x80	; 128
    1354:	3f 2e       	mov	r3, r31
    1356:	82 01       	movw	r16, r4
    1358:	33 fc       	sbrc	r3, 3
    135a:	19 c0       	rjmp	.+50     	; 0x138e <vfprintf+0x1b6>
    135c:	82 2d       	mov	r24, r2
    135e:	90 e0       	ldi	r25, 0x00	; 0
    1360:	88 16       	cp	r8, r24
    1362:	99 06       	cpc	r9, r25
    1364:	a0 f4       	brcc	.+40     	; 0x138e <vfprintf+0x1b6>
    1366:	b6 01       	movw	r22, r12
    1368:	80 e2       	ldi	r24, 0x20	; 32
    136a:	90 e0       	ldi	r25, 0x00	; 0
    136c:	1d d1       	rcall	.+570    	; 0x15a8 <fputc>
    136e:	2a 94       	dec	r2
    1370:	f5 cf       	rjmp	.-22     	; 0x135c <vfprintf+0x184>
    1372:	f5 01       	movw	r30, r10
    1374:	37 fc       	sbrc	r3, 7
    1376:	85 91       	lpm	r24, Z+
    1378:	37 fe       	sbrs	r3, 7
    137a:	81 91       	ld	r24, Z+
    137c:	5f 01       	movw	r10, r30
    137e:	b6 01       	movw	r22, r12
    1380:	90 e0       	ldi	r25, 0x00	; 0
    1382:	12 d1       	rcall	.+548    	; 0x15a8 <fputc>
    1384:	21 10       	cpse	r2, r1
    1386:	2a 94       	dec	r2
    1388:	21 e0       	ldi	r18, 0x01	; 1
    138a:	82 1a       	sub	r8, r18
    138c:	91 08       	sbc	r9, r1
    138e:	81 14       	cp	r8, r1
    1390:	91 04       	cpc	r9, r1
    1392:	79 f7       	brne	.-34     	; 0x1372 <vfprintf+0x19a>
    1394:	e1 c0       	rjmp	.+450    	; 0x1558 <vfprintf+0x380>
    1396:	84 36       	cpi	r24, 0x64	; 100
    1398:	11 f0       	breq	.+4      	; 0x139e <vfprintf+0x1c6>
    139a:	89 36       	cpi	r24, 0x69	; 105
    139c:	39 f5       	brne	.+78     	; 0x13ec <vfprintf+0x214>
    139e:	f8 01       	movw	r30, r16
    13a0:	37 fe       	sbrs	r3, 7
    13a2:	07 c0       	rjmp	.+14     	; 0x13b2 <vfprintf+0x1da>
    13a4:	60 81       	ld	r22, Z
    13a6:	71 81       	ldd	r23, Z+1	; 0x01
    13a8:	82 81       	ldd	r24, Z+2	; 0x02
    13aa:	93 81       	ldd	r25, Z+3	; 0x03
    13ac:	0c 5f       	subi	r16, 0xFC	; 252
    13ae:	1f 4f       	sbci	r17, 0xFF	; 255
    13b0:	08 c0       	rjmp	.+16     	; 0x13c2 <vfprintf+0x1ea>
    13b2:	60 81       	ld	r22, Z
    13b4:	71 81       	ldd	r23, Z+1	; 0x01
    13b6:	07 2e       	mov	r0, r23
    13b8:	00 0c       	add	r0, r0
    13ba:	88 0b       	sbc	r24, r24
    13bc:	99 0b       	sbc	r25, r25
    13be:	0e 5f       	subi	r16, 0xFE	; 254
    13c0:	1f 4f       	sbci	r17, 0xFF	; 255
    13c2:	f3 2d       	mov	r31, r3
    13c4:	ff 76       	andi	r31, 0x6F	; 111
    13c6:	3f 2e       	mov	r3, r31
    13c8:	97 ff       	sbrs	r25, 7
    13ca:	09 c0       	rjmp	.+18     	; 0x13de <vfprintf+0x206>
    13cc:	90 95       	com	r25
    13ce:	80 95       	com	r24
    13d0:	70 95       	com	r23
    13d2:	61 95       	neg	r22
    13d4:	7f 4f       	sbci	r23, 0xFF	; 255
    13d6:	8f 4f       	sbci	r24, 0xFF	; 255
    13d8:	9f 4f       	sbci	r25, 0xFF	; 255
    13da:	f0 68       	ori	r31, 0x80	; 128
    13dc:	3f 2e       	mov	r3, r31
    13de:	2a e0       	ldi	r18, 0x0A	; 10
    13e0:	30 e0       	ldi	r19, 0x00	; 0
    13e2:	a3 01       	movw	r20, r6
    13e4:	1d d1       	rcall	.+570    	; 0x1620 <__ultoa_invert>
    13e6:	88 2e       	mov	r8, r24
    13e8:	86 18       	sub	r8, r6
    13ea:	44 c0       	rjmp	.+136    	; 0x1474 <vfprintf+0x29c>
    13ec:	85 37       	cpi	r24, 0x75	; 117
    13ee:	31 f4       	brne	.+12     	; 0x13fc <vfprintf+0x224>
    13f0:	23 2d       	mov	r18, r3
    13f2:	2f 7e       	andi	r18, 0xEF	; 239
    13f4:	b2 2e       	mov	r11, r18
    13f6:	2a e0       	ldi	r18, 0x0A	; 10
    13f8:	30 e0       	ldi	r19, 0x00	; 0
    13fa:	25 c0       	rjmp	.+74     	; 0x1446 <vfprintf+0x26e>
    13fc:	93 2d       	mov	r25, r3
    13fe:	99 7f       	andi	r25, 0xF9	; 249
    1400:	b9 2e       	mov	r11, r25
    1402:	8f 36       	cpi	r24, 0x6F	; 111
    1404:	c1 f0       	breq	.+48     	; 0x1436 <vfprintf+0x25e>
    1406:	18 f4       	brcc	.+6      	; 0x140e <vfprintf+0x236>
    1408:	88 35       	cpi	r24, 0x58	; 88
    140a:	79 f0       	breq	.+30     	; 0x142a <vfprintf+0x252>
    140c:	ae c0       	rjmp	.+348    	; 0x156a <vfprintf+0x392>
    140e:	80 37       	cpi	r24, 0x70	; 112
    1410:	19 f0       	breq	.+6      	; 0x1418 <vfprintf+0x240>
    1412:	88 37       	cpi	r24, 0x78	; 120
    1414:	21 f0       	breq	.+8      	; 0x141e <vfprintf+0x246>
    1416:	a9 c0       	rjmp	.+338    	; 0x156a <vfprintf+0x392>
    1418:	e9 2f       	mov	r30, r25
    141a:	e0 61       	ori	r30, 0x10	; 16
    141c:	be 2e       	mov	r11, r30
    141e:	b4 fe       	sbrs	r11, 4
    1420:	0d c0       	rjmp	.+26     	; 0x143c <vfprintf+0x264>
    1422:	fb 2d       	mov	r31, r11
    1424:	f4 60       	ori	r31, 0x04	; 4
    1426:	bf 2e       	mov	r11, r31
    1428:	09 c0       	rjmp	.+18     	; 0x143c <vfprintf+0x264>
    142a:	34 fe       	sbrs	r3, 4
    142c:	0a c0       	rjmp	.+20     	; 0x1442 <vfprintf+0x26a>
    142e:	29 2f       	mov	r18, r25
    1430:	26 60       	ori	r18, 0x06	; 6
    1432:	b2 2e       	mov	r11, r18
    1434:	06 c0       	rjmp	.+12     	; 0x1442 <vfprintf+0x26a>
    1436:	28 e0       	ldi	r18, 0x08	; 8
    1438:	30 e0       	ldi	r19, 0x00	; 0
    143a:	05 c0       	rjmp	.+10     	; 0x1446 <vfprintf+0x26e>
    143c:	20 e1       	ldi	r18, 0x10	; 16
    143e:	30 e0       	ldi	r19, 0x00	; 0
    1440:	02 c0       	rjmp	.+4      	; 0x1446 <vfprintf+0x26e>
    1442:	20 e1       	ldi	r18, 0x10	; 16
    1444:	32 e0       	ldi	r19, 0x02	; 2
    1446:	f8 01       	movw	r30, r16
    1448:	b7 fe       	sbrs	r11, 7
    144a:	07 c0       	rjmp	.+14     	; 0x145a <vfprintf+0x282>
    144c:	60 81       	ld	r22, Z
    144e:	71 81       	ldd	r23, Z+1	; 0x01
    1450:	82 81       	ldd	r24, Z+2	; 0x02
    1452:	93 81       	ldd	r25, Z+3	; 0x03
    1454:	0c 5f       	subi	r16, 0xFC	; 252
    1456:	1f 4f       	sbci	r17, 0xFF	; 255
    1458:	06 c0       	rjmp	.+12     	; 0x1466 <vfprintf+0x28e>
    145a:	60 81       	ld	r22, Z
    145c:	71 81       	ldd	r23, Z+1	; 0x01
    145e:	80 e0       	ldi	r24, 0x00	; 0
    1460:	90 e0       	ldi	r25, 0x00	; 0
    1462:	0e 5f       	subi	r16, 0xFE	; 254
    1464:	1f 4f       	sbci	r17, 0xFF	; 255
    1466:	a3 01       	movw	r20, r6
    1468:	db d0       	rcall	.+438    	; 0x1620 <__ultoa_invert>
    146a:	88 2e       	mov	r8, r24
    146c:	86 18       	sub	r8, r6
    146e:	fb 2d       	mov	r31, r11
    1470:	ff 77       	andi	r31, 0x7F	; 127
    1472:	3f 2e       	mov	r3, r31
    1474:	36 fe       	sbrs	r3, 6
    1476:	0d c0       	rjmp	.+26     	; 0x1492 <vfprintf+0x2ba>
    1478:	23 2d       	mov	r18, r3
    147a:	2e 7f       	andi	r18, 0xFE	; 254
    147c:	a2 2e       	mov	r10, r18
    147e:	89 14       	cp	r8, r9
    1480:	58 f4       	brcc	.+22     	; 0x1498 <vfprintf+0x2c0>
    1482:	34 fe       	sbrs	r3, 4
    1484:	0b c0       	rjmp	.+22     	; 0x149c <vfprintf+0x2c4>
    1486:	32 fc       	sbrc	r3, 2
    1488:	09 c0       	rjmp	.+18     	; 0x149c <vfprintf+0x2c4>
    148a:	83 2d       	mov	r24, r3
    148c:	8e 7e       	andi	r24, 0xEE	; 238
    148e:	a8 2e       	mov	r10, r24
    1490:	05 c0       	rjmp	.+10     	; 0x149c <vfprintf+0x2c4>
    1492:	b8 2c       	mov	r11, r8
    1494:	a3 2c       	mov	r10, r3
    1496:	03 c0       	rjmp	.+6      	; 0x149e <vfprintf+0x2c6>
    1498:	b8 2c       	mov	r11, r8
    149a:	01 c0       	rjmp	.+2      	; 0x149e <vfprintf+0x2c6>
    149c:	b9 2c       	mov	r11, r9
    149e:	a4 fe       	sbrs	r10, 4
    14a0:	0f c0       	rjmp	.+30     	; 0x14c0 <vfprintf+0x2e8>
    14a2:	fe 01       	movw	r30, r28
    14a4:	e8 0d       	add	r30, r8
    14a6:	f1 1d       	adc	r31, r1
    14a8:	80 81       	ld	r24, Z
    14aa:	80 33       	cpi	r24, 0x30	; 48
    14ac:	21 f4       	brne	.+8      	; 0x14b6 <vfprintf+0x2de>
    14ae:	9a 2d       	mov	r25, r10
    14b0:	99 7e       	andi	r25, 0xE9	; 233
    14b2:	a9 2e       	mov	r10, r25
    14b4:	09 c0       	rjmp	.+18     	; 0x14c8 <vfprintf+0x2f0>
    14b6:	a2 fe       	sbrs	r10, 2
    14b8:	06 c0       	rjmp	.+12     	; 0x14c6 <vfprintf+0x2ee>
    14ba:	b3 94       	inc	r11
    14bc:	b3 94       	inc	r11
    14be:	04 c0       	rjmp	.+8      	; 0x14c8 <vfprintf+0x2f0>
    14c0:	8a 2d       	mov	r24, r10
    14c2:	86 78       	andi	r24, 0x86	; 134
    14c4:	09 f0       	breq	.+2      	; 0x14c8 <vfprintf+0x2f0>
    14c6:	b3 94       	inc	r11
    14c8:	a3 fc       	sbrc	r10, 3
    14ca:	10 c0       	rjmp	.+32     	; 0x14ec <vfprintf+0x314>
    14cc:	a0 fe       	sbrs	r10, 0
    14ce:	06 c0       	rjmp	.+12     	; 0x14dc <vfprintf+0x304>
    14d0:	b2 14       	cp	r11, r2
    14d2:	80 f4       	brcc	.+32     	; 0x14f4 <vfprintf+0x31c>
    14d4:	28 0c       	add	r2, r8
    14d6:	92 2c       	mov	r9, r2
    14d8:	9b 18       	sub	r9, r11
    14da:	0d c0       	rjmp	.+26     	; 0x14f6 <vfprintf+0x31e>
    14dc:	b2 14       	cp	r11, r2
    14de:	58 f4       	brcc	.+22     	; 0x14f6 <vfprintf+0x31e>
    14e0:	b6 01       	movw	r22, r12
    14e2:	80 e2       	ldi	r24, 0x20	; 32
    14e4:	90 e0       	ldi	r25, 0x00	; 0
    14e6:	60 d0       	rcall	.+192    	; 0x15a8 <fputc>
    14e8:	b3 94       	inc	r11
    14ea:	f8 cf       	rjmp	.-16     	; 0x14dc <vfprintf+0x304>
    14ec:	b2 14       	cp	r11, r2
    14ee:	18 f4       	brcc	.+6      	; 0x14f6 <vfprintf+0x31e>
    14f0:	2b 18       	sub	r2, r11
    14f2:	02 c0       	rjmp	.+4      	; 0x14f8 <vfprintf+0x320>
    14f4:	98 2c       	mov	r9, r8
    14f6:	21 2c       	mov	r2, r1
    14f8:	a4 fe       	sbrs	r10, 4
    14fa:	0f c0       	rjmp	.+30     	; 0x151a <vfprintf+0x342>
    14fc:	b6 01       	movw	r22, r12
    14fe:	80 e3       	ldi	r24, 0x30	; 48
    1500:	90 e0       	ldi	r25, 0x00	; 0
    1502:	52 d0       	rcall	.+164    	; 0x15a8 <fputc>
    1504:	a2 fe       	sbrs	r10, 2
    1506:	16 c0       	rjmp	.+44     	; 0x1534 <vfprintf+0x35c>
    1508:	a1 fc       	sbrc	r10, 1
    150a:	03 c0       	rjmp	.+6      	; 0x1512 <vfprintf+0x33a>
    150c:	88 e7       	ldi	r24, 0x78	; 120
    150e:	90 e0       	ldi	r25, 0x00	; 0
    1510:	02 c0       	rjmp	.+4      	; 0x1516 <vfprintf+0x33e>
    1512:	88 e5       	ldi	r24, 0x58	; 88
    1514:	90 e0       	ldi	r25, 0x00	; 0
    1516:	b6 01       	movw	r22, r12
    1518:	0c c0       	rjmp	.+24     	; 0x1532 <vfprintf+0x35a>
    151a:	8a 2d       	mov	r24, r10
    151c:	86 78       	andi	r24, 0x86	; 134
    151e:	51 f0       	breq	.+20     	; 0x1534 <vfprintf+0x35c>
    1520:	a1 fe       	sbrs	r10, 1
    1522:	02 c0       	rjmp	.+4      	; 0x1528 <vfprintf+0x350>
    1524:	8b e2       	ldi	r24, 0x2B	; 43
    1526:	01 c0       	rjmp	.+2      	; 0x152a <vfprintf+0x352>
    1528:	80 e2       	ldi	r24, 0x20	; 32
    152a:	a7 fc       	sbrc	r10, 7
    152c:	8d e2       	ldi	r24, 0x2D	; 45
    152e:	b6 01       	movw	r22, r12
    1530:	90 e0       	ldi	r25, 0x00	; 0
    1532:	3a d0       	rcall	.+116    	; 0x15a8 <fputc>
    1534:	89 14       	cp	r8, r9
    1536:	30 f4       	brcc	.+12     	; 0x1544 <vfprintf+0x36c>
    1538:	b6 01       	movw	r22, r12
    153a:	80 e3       	ldi	r24, 0x30	; 48
    153c:	90 e0       	ldi	r25, 0x00	; 0
    153e:	34 d0       	rcall	.+104    	; 0x15a8 <fputc>
    1540:	9a 94       	dec	r9
    1542:	f8 cf       	rjmp	.-16     	; 0x1534 <vfprintf+0x35c>
    1544:	8a 94       	dec	r8
    1546:	f3 01       	movw	r30, r6
    1548:	e8 0d       	add	r30, r8
    154a:	f1 1d       	adc	r31, r1
    154c:	80 81       	ld	r24, Z
    154e:	b6 01       	movw	r22, r12
    1550:	90 e0       	ldi	r25, 0x00	; 0
    1552:	2a d0       	rcall	.+84     	; 0x15a8 <fputc>
    1554:	81 10       	cpse	r8, r1
    1556:	f6 cf       	rjmp	.-20     	; 0x1544 <vfprintf+0x36c>
    1558:	22 20       	and	r2, r2
    155a:	09 f4       	brne	.+2      	; 0x155e <vfprintf+0x386>
    155c:	4e ce       	rjmp	.-868    	; 0x11fa <vfprintf+0x22>
    155e:	b6 01       	movw	r22, r12
    1560:	80 e2       	ldi	r24, 0x20	; 32
    1562:	90 e0       	ldi	r25, 0x00	; 0
    1564:	21 d0       	rcall	.+66     	; 0x15a8 <fputc>
    1566:	2a 94       	dec	r2
    1568:	f7 cf       	rjmp	.-18     	; 0x1558 <vfprintf+0x380>
    156a:	f6 01       	movw	r30, r12
    156c:	86 81       	ldd	r24, Z+6	; 0x06
    156e:	97 81       	ldd	r25, Z+7	; 0x07
    1570:	02 c0       	rjmp	.+4      	; 0x1576 <vfprintf+0x39e>
    1572:	8f ef       	ldi	r24, 0xFF	; 255
    1574:	9f ef       	ldi	r25, 0xFF	; 255
    1576:	2b 96       	adiw	r28, 0x0b	; 11
    1578:	e2 e1       	ldi	r30, 0x12	; 18
    157a:	cc c0       	rjmp	.+408    	; 0x1714 <__epilogue_restores__>

0000157c <strnlen_P>:
    157c:	fc 01       	movw	r30, r24
    157e:	05 90       	lpm	r0, Z+
    1580:	61 50       	subi	r22, 0x01	; 1
    1582:	70 40       	sbci	r23, 0x00	; 0
    1584:	01 10       	cpse	r0, r1
    1586:	d8 f7       	brcc	.-10     	; 0x157e <strnlen_P+0x2>
    1588:	80 95       	com	r24
    158a:	90 95       	com	r25
    158c:	8e 0f       	add	r24, r30
    158e:	9f 1f       	adc	r25, r31
    1590:	08 95       	ret

00001592 <strnlen>:
    1592:	fc 01       	movw	r30, r24
    1594:	61 50       	subi	r22, 0x01	; 1
    1596:	70 40       	sbci	r23, 0x00	; 0
    1598:	01 90       	ld	r0, Z+
    159a:	01 10       	cpse	r0, r1
    159c:	d8 f7       	brcc	.-10     	; 0x1594 <strnlen+0x2>
    159e:	80 95       	com	r24
    15a0:	90 95       	com	r25
    15a2:	8e 0f       	add	r24, r30
    15a4:	9f 1f       	adc	r25, r31
    15a6:	08 95       	ret

000015a8 <fputc>:
    15a8:	0f 93       	push	r16
    15aa:	1f 93       	push	r17
    15ac:	cf 93       	push	r28
    15ae:	df 93       	push	r29
    15b0:	fb 01       	movw	r30, r22
    15b2:	23 81       	ldd	r18, Z+3	; 0x03
    15b4:	21 fd       	sbrc	r18, 1
    15b6:	03 c0       	rjmp	.+6      	; 0x15be <fputc+0x16>
    15b8:	8f ef       	ldi	r24, 0xFF	; 255
    15ba:	9f ef       	ldi	r25, 0xFF	; 255
    15bc:	2c c0       	rjmp	.+88     	; 0x1616 <fputc+0x6e>
    15be:	22 ff       	sbrs	r18, 2
    15c0:	16 c0       	rjmp	.+44     	; 0x15ee <fputc+0x46>
    15c2:	46 81       	ldd	r20, Z+6	; 0x06
    15c4:	57 81       	ldd	r21, Z+7	; 0x07
    15c6:	24 81       	ldd	r18, Z+4	; 0x04
    15c8:	35 81       	ldd	r19, Z+5	; 0x05
    15ca:	42 17       	cp	r20, r18
    15cc:	53 07       	cpc	r21, r19
    15ce:	44 f4       	brge	.+16     	; 0x15e0 <fputc+0x38>
    15d0:	a0 81       	ld	r26, Z
    15d2:	b1 81       	ldd	r27, Z+1	; 0x01
    15d4:	9d 01       	movw	r18, r26
    15d6:	2f 5f       	subi	r18, 0xFF	; 255
    15d8:	3f 4f       	sbci	r19, 0xFF	; 255
    15da:	31 83       	std	Z+1, r19	; 0x01
    15dc:	20 83       	st	Z, r18
    15de:	8c 93       	st	X, r24
    15e0:	26 81       	ldd	r18, Z+6	; 0x06
    15e2:	37 81       	ldd	r19, Z+7	; 0x07
    15e4:	2f 5f       	subi	r18, 0xFF	; 255
    15e6:	3f 4f       	sbci	r19, 0xFF	; 255
    15e8:	37 83       	std	Z+7, r19	; 0x07
    15ea:	26 83       	std	Z+6, r18	; 0x06
    15ec:	14 c0       	rjmp	.+40     	; 0x1616 <fputc+0x6e>
    15ee:	8b 01       	movw	r16, r22
    15f0:	ec 01       	movw	r28, r24
    15f2:	fb 01       	movw	r30, r22
    15f4:	00 84       	ldd	r0, Z+8	; 0x08
    15f6:	f1 85       	ldd	r31, Z+9	; 0x09
    15f8:	e0 2d       	mov	r30, r0
    15fa:	09 95       	icall
    15fc:	89 2b       	or	r24, r25
    15fe:	e1 f6       	brne	.-72     	; 0x15b8 <fputc+0x10>
    1600:	d8 01       	movw	r26, r16
    1602:	16 96       	adiw	r26, 0x06	; 6
    1604:	8d 91       	ld	r24, X+
    1606:	9c 91       	ld	r25, X
    1608:	17 97       	sbiw	r26, 0x07	; 7
    160a:	01 96       	adiw	r24, 0x01	; 1
    160c:	17 96       	adiw	r26, 0x07	; 7
    160e:	9c 93       	st	X, r25
    1610:	8e 93       	st	-X, r24
    1612:	16 97       	sbiw	r26, 0x06	; 6
    1614:	ce 01       	movw	r24, r28
    1616:	df 91       	pop	r29
    1618:	cf 91       	pop	r28
    161a:	1f 91       	pop	r17
    161c:	0f 91       	pop	r16
    161e:	08 95       	ret

00001620 <__ultoa_invert>:
    1620:	fa 01       	movw	r30, r20
    1622:	aa 27       	eor	r26, r26
    1624:	28 30       	cpi	r18, 0x08	; 8
    1626:	51 f1       	breq	.+84     	; 0x167c <__ultoa_invert+0x5c>
    1628:	20 31       	cpi	r18, 0x10	; 16
    162a:	81 f1       	breq	.+96     	; 0x168c <__ultoa_invert+0x6c>
    162c:	e8 94       	clt
    162e:	6f 93       	push	r22
    1630:	6e 7f       	andi	r22, 0xFE	; 254
    1632:	6e 5f       	subi	r22, 0xFE	; 254
    1634:	7f 4f       	sbci	r23, 0xFF	; 255
    1636:	8f 4f       	sbci	r24, 0xFF	; 255
    1638:	9f 4f       	sbci	r25, 0xFF	; 255
    163a:	af 4f       	sbci	r26, 0xFF	; 255
    163c:	b1 e0       	ldi	r27, 0x01	; 1
    163e:	3e d0       	rcall	.+124    	; 0x16bc <__ultoa_invert+0x9c>
    1640:	b4 e0       	ldi	r27, 0x04	; 4
    1642:	3c d0       	rcall	.+120    	; 0x16bc <__ultoa_invert+0x9c>
    1644:	67 0f       	add	r22, r23
    1646:	78 1f       	adc	r23, r24
    1648:	89 1f       	adc	r24, r25
    164a:	9a 1f       	adc	r25, r26
    164c:	a1 1d       	adc	r26, r1
    164e:	68 0f       	add	r22, r24
    1650:	79 1f       	adc	r23, r25
    1652:	8a 1f       	adc	r24, r26
    1654:	91 1d       	adc	r25, r1
    1656:	a1 1d       	adc	r26, r1
    1658:	6a 0f       	add	r22, r26
    165a:	71 1d       	adc	r23, r1
    165c:	81 1d       	adc	r24, r1
    165e:	91 1d       	adc	r25, r1
    1660:	a1 1d       	adc	r26, r1
    1662:	20 d0       	rcall	.+64     	; 0x16a4 <__ultoa_invert+0x84>
    1664:	09 f4       	brne	.+2      	; 0x1668 <__ultoa_invert+0x48>
    1666:	68 94       	set
    1668:	3f 91       	pop	r19
    166a:	2a e0       	ldi	r18, 0x0A	; 10
    166c:	26 9f       	mul	r18, r22
    166e:	11 24       	eor	r1, r1
    1670:	30 19       	sub	r19, r0
    1672:	30 5d       	subi	r19, 0xD0	; 208
    1674:	31 93       	st	Z+, r19
    1676:	de f6       	brtc	.-74     	; 0x162e <__ultoa_invert+0xe>
    1678:	cf 01       	movw	r24, r30
    167a:	08 95       	ret
    167c:	46 2f       	mov	r20, r22
    167e:	47 70       	andi	r20, 0x07	; 7
    1680:	40 5d       	subi	r20, 0xD0	; 208
    1682:	41 93       	st	Z+, r20
    1684:	b3 e0       	ldi	r27, 0x03	; 3
    1686:	0f d0       	rcall	.+30     	; 0x16a6 <__ultoa_invert+0x86>
    1688:	c9 f7       	brne	.-14     	; 0x167c <__ultoa_invert+0x5c>
    168a:	f6 cf       	rjmp	.-20     	; 0x1678 <__ultoa_invert+0x58>
    168c:	46 2f       	mov	r20, r22
    168e:	4f 70       	andi	r20, 0x0F	; 15
    1690:	40 5d       	subi	r20, 0xD0	; 208
    1692:	4a 33       	cpi	r20, 0x3A	; 58
    1694:	18 f0       	brcs	.+6      	; 0x169c <__ultoa_invert+0x7c>
    1696:	49 5d       	subi	r20, 0xD9	; 217
    1698:	31 fd       	sbrc	r19, 1
    169a:	40 52       	subi	r20, 0x20	; 32
    169c:	41 93       	st	Z+, r20
    169e:	02 d0       	rcall	.+4      	; 0x16a4 <__ultoa_invert+0x84>
    16a0:	a9 f7       	brne	.-22     	; 0x168c <__ultoa_invert+0x6c>
    16a2:	ea cf       	rjmp	.-44     	; 0x1678 <__ultoa_invert+0x58>
    16a4:	b4 e0       	ldi	r27, 0x04	; 4
    16a6:	a6 95       	lsr	r26
    16a8:	97 95       	ror	r25
    16aa:	87 95       	ror	r24
    16ac:	77 95       	ror	r23
    16ae:	67 95       	ror	r22
    16b0:	ba 95       	dec	r27
    16b2:	c9 f7       	brne	.-14     	; 0x16a6 <__ultoa_invert+0x86>
    16b4:	00 97       	sbiw	r24, 0x00	; 0
    16b6:	61 05       	cpc	r22, r1
    16b8:	71 05       	cpc	r23, r1
    16ba:	08 95       	ret
    16bc:	9b 01       	movw	r18, r22
    16be:	ac 01       	movw	r20, r24
    16c0:	0a 2e       	mov	r0, r26
    16c2:	06 94       	lsr	r0
    16c4:	57 95       	ror	r21
    16c6:	47 95       	ror	r20
    16c8:	37 95       	ror	r19
    16ca:	27 95       	ror	r18
    16cc:	ba 95       	dec	r27
    16ce:	c9 f7       	brne	.-14     	; 0x16c2 <__ultoa_invert+0xa2>
    16d0:	62 0f       	add	r22, r18
    16d2:	73 1f       	adc	r23, r19
    16d4:	84 1f       	adc	r24, r20
    16d6:	95 1f       	adc	r25, r21
    16d8:	a0 1d       	adc	r26, r0
    16da:	08 95       	ret

000016dc <__prologue_saves__>:
    16dc:	2f 92       	push	r2
    16de:	3f 92       	push	r3
    16e0:	4f 92       	push	r4
    16e2:	5f 92       	push	r5
    16e4:	6f 92       	push	r6
    16e6:	7f 92       	push	r7
    16e8:	8f 92       	push	r8
    16ea:	9f 92       	push	r9
    16ec:	af 92       	push	r10
    16ee:	bf 92       	push	r11
    16f0:	cf 92       	push	r12
    16f2:	df 92       	push	r13
    16f4:	ef 92       	push	r14
    16f6:	ff 92       	push	r15
    16f8:	0f 93       	push	r16
    16fa:	1f 93       	push	r17
    16fc:	cf 93       	push	r28
    16fe:	df 93       	push	r29
    1700:	cd b7       	in	r28, 0x3d	; 61
    1702:	de b7       	in	r29, 0x3e	; 62
    1704:	ca 1b       	sub	r28, r26
    1706:	db 0b       	sbc	r29, r27
    1708:	0f b6       	in	r0, 0x3f	; 63
    170a:	f8 94       	cli
    170c:	de bf       	out	0x3e, r29	; 62
    170e:	0f be       	out	0x3f, r0	; 63
    1710:	cd bf       	out	0x3d, r28	; 61
    1712:	09 94       	ijmp

00001714 <__epilogue_restores__>:
    1714:	2a 88       	ldd	r2, Y+18	; 0x12
    1716:	39 88       	ldd	r3, Y+17	; 0x11
    1718:	48 88       	ldd	r4, Y+16	; 0x10
    171a:	5f 84       	ldd	r5, Y+15	; 0x0f
    171c:	6e 84       	ldd	r6, Y+14	; 0x0e
    171e:	7d 84       	ldd	r7, Y+13	; 0x0d
    1720:	8c 84       	ldd	r8, Y+12	; 0x0c
    1722:	9b 84       	ldd	r9, Y+11	; 0x0b
    1724:	aa 84       	ldd	r10, Y+10	; 0x0a
    1726:	b9 84       	ldd	r11, Y+9	; 0x09
    1728:	c8 84       	ldd	r12, Y+8	; 0x08
    172a:	df 80       	ldd	r13, Y+7	; 0x07
    172c:	ee 80       	ldd	r14, Y+6	; 0x06
    172e:	fd 80       	ldd	r15, Y+5	; 0x05
    1730:	0c 81       	ldd	r16, Y+4	; 0x04
    1732:	1b 81       	ldd	r17, Y+3	; 0x03
    1734:	aa 81       	ldd	r26, Y+2	; 0x02
    1736:	b9 81       	ldd	r27, Y+1	; 0x01
    1738:	ce 0f       	add	r28, r30
    173a:	d1 1d       	adc	r29, r1
    173c:	0f b6       	in	r0, 0x3f	; 63
    173e:	f8 94       	cli
    1740:	de bf       	out	0x3e, r29	; 62
    1742:	0f be       	out	0x3f, r0	; 63
    1744:	cd bf       	out	0x3d, r28	; 61
    1746:	ed 01       	movw	r28, r26
    1748:	08 95       	ret

0000174a <__do_global_dtors>:
    174a:	10 e0       	ldi	r17, 0x00	; 0
    174c:	cf eb       	ldi	r28, 0xBF	; 191
    174e:	d0 e0       	ldi	r29, 0x00	; 0
    1750:	03 c0       	rjmp	.+6      	; 0x1758 <__do_global_dtors+0xe>
    1752:	fe 01       	movw	r30, r28
    1754:	fb db       	rcall	.-2058   	; 0xf4c <__tablejump2__>
    1756:	21 96       	adiw	r28, 0x01	; 1
    1758:	c0 3c       	cpi	r28, 0xC0	; 192
    175a:	d1 07       	cpc	r29, r17
    175c:	d1 f7       	brne	.-12     	; 0x1752 <__do_global_dtors+0x8>
    175e:	f8 94       	cli

00001760 <__stop_program>:
    1760:	ff cf       	rjmp	.-2      	; 0x1760 <__stop_program>
